# 1.3 Дизайн API для generic CLI

**Тип:** Sequential
**Зависимости:** 1.1 Инвентаризация, 1.2 Анализ зависимостей
**Время:** ~1 час

---

## Задача

Спроектировать публичный API для `@mcp-framework/cli`, который будет:
- Generic (работает с любым MCP сервером)
- Расширяемый (легко добавить новые промпты, валидаторы)
- Типобезопасный (максимум TypeScript inference)
- Простой в использовании

---

## Действия

### 1. Дизайн базовых типов

**BaseMCPServerConfig:**
```typescript
/**
 * Базовая конфигурация для любого MCP сервера
 */
export interface BaseMCPServerConfig {
  /** Абсолютный путь к проекту */
  projectPath: string;

  /** Уровень логирования */
  logLevel?: 'debug' | 'info' | 'warn' | 'error';

  /** Дополнительные env переменные для передачи в MCP сервер */
  env?: Record<string, string>;
}
```

**Generic MCPConnector:**
```typescript
export interface MCPConnector<TConfig extends BaseMCPServerConfig = BaseMCPServerConfig> {
  getClientInfo(): MCPClientInfo;
  isInstalled(): Promise<boolean>;
  getStatus(): Promise<ConnectionStatus>;
  connect(config: TConfig): Promise<void>;
  disconnect(): Promise<void>;
  validateConfig(config: TConfig): Promise<string[]>;
}
```

### 2. Дизайн системы промптов

**ConfigPromptDefinition:**
```typescript
export type PromptType = 'input' | 'password' | 'list' | 'confirm' | 'number';

export interface ConfigPromptDefinition<T, K extends keyof T = keyof T> {
  /** Имя поля в конфигурации */
  name: K;

  /** Тип промпта */
  type: PromptType;

  /** Сообщение для пользователя */
  message: string;

  /** Значение по умолчанию */
  default?: T[K] | ((savedConfig?: Partial<T>) => T[K]);

  /** Валидация */
  validate?: (value: T[K]) => string | true;

  /** Варианты выбора (для type: 'list') */
  choices?: Array<{ name: string; value: T[K] }>;

  /** Условное отображение */
  when?: (answers: Partial<T>) => boolean;
}
```

**Пример использования:**
```typescript
// В yandex-tracker
const prompts: ConfigPromptDefinition<YandexTrackerMCPConfig>[] = [
  {
    name: 'token',
    type: 'password',
    message: 'OAuth токен Яндекс.Трекера:',
    validate: (v) => v.length > 0 || 'Токен обязателен',
  },
  {
    name: 'orgId',
    type: 'input',
    message: 'ID организации:',
    default: (saved) => saved?.orgId,
    validate: (v) => v.length > 0 || 'ID обязателен',
  },
  {
    name: 'logLevel',
    type: 'list',
    message: 'Уровень логирования:',
    choices: [
      { name: 'Debug', value: 'debug' },
      { name: 'Info', value: 'info' },
      { name: 'Warning', value: 'warn' },
      { name: 'Error', value: 'error' },
    ],
    default: 'info',
  },
];
```

### 3. Дизайн ConfigManager

**Generic ConfigManager:**
```typescript
export interface ConfigManagerOptions<TConfig extends BaseMCPServerConfig> {
  /** Название проекта (для .{projectName}/config.json) */
  projectName: string;

  /** Поля для сохранения (безопасные, без секретов) */
  safeFields: Array<keyof TConfig>;

  /** Serialize/deserialize hooks */
  serialize?: (config: TConfig) => Record<string, unknown>;
  deserialize?: (data: Record<string, unknown>) => Partial<TConfig>;
}

export class ConfigManager<TConfig extends BaseMCPServerConfig> {
  constructor(private options: ConfigManagerOptions<TConfig>) {}

  async load(): Promise<Partial<TConfig> | undefined> {
    // Загрузка из ~/.{projectName}/config.json
  }

  async save(config: TConfig): Promise<void> {
    // Сохранение только safeFields
  }

  async delete(): Promise<void> {
    // Удаление конфига
  }
}
```

### 4. Дизайн CLI команд

**Connect команда:**
```typescript
export interface ConnectCommandOptions<TConfig extends BaseMCPServerConfig> {
  /** Реестр коннекторов */
  registry: ConnectorRegistry<TConfig>;

  /** Менеджер конфигурации */
  configManager: ConfigManager<TConfig>;

  /** Промпты для сбора конфигурации */
  configPrompts: ConfigPromptDefinition<TConfig>[];

  /** CLI опции */
  cliOptions?: {
    client?: string;
  };
}

export async function connectCommand<TConfig extends BaseMCPServerConfig>(
  options: ConnectCommandOptions<TConfig>
): Promise<void>;
```

### 5. Дизайн Entry Point

**Для yandex-tracker:**
```typescript
// packages/servers/yandex-tracker/src/cli/bin/mcp-connect.ts
import { program } from 'commander';
import { connectCommand, disconnectCommand, statusCommand, listCommand } from '@mcp-framework/cli';
import { ConnectorRegistry, ConfigManager } from '@mcp-framework/cli';
import { ytConfigPrompts, YandexTrackerMCPConfig } from '../config.js';

const registry = new ConnectorRegistry<YandexTrackerMCPConfig>();
const configManager = new ConfigManager<YandexTrackerMCPConfig>({
  projectName: 'fractalizer_mcp_yandex_tracker',
  safeFields: ['orgId', 'logLevel', 'apiBase', 'requestTimeout'],
});

program
  .command('connect')
  .option('--client <name>', 'MCP клиент')
  .action(async (opts) => {
    await connectCommand({
      registry,
      configManager,
      configPrompts: ytConfigPrompts,
      cliOptions: opts,
    });
  });

// ... другие команды

program.parse();
```

---

## Результат

**Создать файл:** `API_DESIGN.md` в корне плана

**Содержание:**
1. Полное определение всех public типов и интерфейсов
2. Примеры использования для разных сценариев
3. Сравнение "До" и "После" (yandex-tracker текущий CLI vs framework CLI)
4. Диаграмма архитектуры компонентов
5. Список breaking changes для пользователей

**Также создать:**
- `packages/framework/cli/src/types.ts` (draft) — базовые типы
- `packages/framework/cli/API.md` (draft) — публичный API

---

## Критерии готовности

- [x] Базовые типы определены и документированы
- [x] Система промптов спроектирована
- [x] ConfigManager API определен
- [x] CLI команды имеют четкую сигнатуру
- [x] Пример использования в yandex-tracker написан
- [x] Документ `API_DESIGN.md` создан
- [x] Draft файлы созданы (включены в API_DESIGN.md)

---

## ✅ Статус: ЗАВЕРШЕНО

**Дата завершения:** 2025-11-22
**Результат:** [API_DESIGN.md](./API_DESIGN.md)

**Ключевые решения:**
- Generic типы через `TConfig extends BaseMCPServerConfig`
- Система промптов через `ConfigPromptDefinition<TConfig>[]`
- Параметризованный ConfigManager с `safeFields`
- Generic команды принимают registry + configManager + prompts
- Полная обратная совместимость для конечных пользователей
- Breaking changes только для internal API (легко мигрировать)
