# 3.1 Generic ConfigManager

**Тип:** Parallel (можно выполнять одновременно с 3.2 и 3.3)
**Зависимости:** 2.3 Коннекторы
**Время:** ~1 час

---

## Задача

Создать generic ConfigManager, который позволяет любому MCP серверу:
- Определить свою структуру конфигурации (токены, API ключи, endpoints и т.д.)
- Указать, какие поля безопасны для сохранения (не содержат секреты)
- Настроить сериализацию/десериализацию

---

## Действия

### 1. Создать интерфейс ConfigManagerOptions

**Файл:** `src/utils/config-manager.ts`

```typescript
import type { BaseMCPServerConfig } from '../types.js';

/**
 * Опции для ConfigManager
 */
export interface ConfigManagerOptions<TConfig extends BaseMCPServerConfig> {
  /**
   * Название проекта
   * Используется для создания ~/.{projectName}/config.json
   *
   * @example "fractalizer_mcp_yandex_tracker"
   * @example "my_custom_mcp_server"
   */
  projectName: string;

  /**
   * Поля конфигурации для сохранения
   * ВАЖНО: НЕ включать секретные поля (токены, пароли)
   *
   * @example ['orgId', 'logLevel', 'apiBase']
   */
  safeFields: Array<keyof TConfig>;

  /**
   * Кастомная сериализация конфигурации (опционально)
   * Полезно для преобразования сложных типов
   */
  serialize?: (config: TConfig) => Record<string, unknown>;

  /**
   * Кастомная десериализация (опционально)
   * Полезно для валидации загруженных данных
   */
  deserialize?: (data: Record<string, unknown>) => Partial<TConfig>;
}
```

### 2. Создать класс ConfigManager

```typescript
import * as path from 'path';
import { FileManager } from './file-manager.js';

/**
 * Generic менеджер конфигурации MCP сервера
 *
 * Сохраняет только безопасные поля (без секретов) в ~/.{projectName}/config.json
 */
export class ConfigManager<TConfig extends BaseMCPServerConfig> {
  private readonly configPath: string;

  constructor(private readonly options: ConfigManagerOptions<TConfig>) {
    const homeDir = FileManager.getHomeDir();
    const configDir = `.${options.projectName}`;
    this.configPath = path.join(homeDir, configDir, 'config.json');
  }

  /**
   * Загрузить сохраненную конфигурацию
   */
  async load(): Promise<Partial<TConfig> | undefined> {
    try {
      if (!(await FileManager.exists(this.configPath))) {
        return undefined;
      }

      const data = await FileManager.readJSON<Record<string, unknown>>(this.configPath);

      // Кастомная десериализация если задана
      if (this.options.deserialize) {
        return this.options.deserialize(data);
      }

      return data as Partial<TConfig>;
    } catch {
      return undefined;
    }
  }

  /**
   * Сохранить конфигурацию
   * Автоматически фильтрует только безопасные поля
   */
  async save(config: TConfig): Promise<void> {
    const configDir = path.dirname(this.configPath);
    await FileManager.ensureDir(configDir);

    // Сохраняем только безопасные поля
    const safeConfig: Partial<TConfig> = {};
    for (const field of this.options.safeFields) {
      if (field in config) {
        safeConfig[field] = config[field];
      }
    }

    // Кастомная сериализация если задана
    const dataToSave = this.options.serialize
      ? this.options.serialize(config)
      : (safeConfig as Record<string, unknown>);

    await FileManager.writeJSON(this.configPath, dataToSave);

    // Безопасные права доступа (только владелец)
    await FileManager.setPermissions(this.configPath, 0o600);
  }

  /**
   * Удалить сохраненную конфигурацию
   */
  async delete(): Promise<void> {
    if (await FileManager.exists(this.configPath)) {
      const fs = await import('fs/promises');
      await fs.unlink(this.configPath);
    }
  }

  /**
   * Проверить существование конфигурации
   */
  async exists(): Promise<boolean> {
    return FileManager.exists(this.configPath);
  }

  /**
   * Получить путь к файлу конфигурации
   */
  getConfigPath(): string {
    return this.configPath;
  }
}
```

### 3. Пример использования для Yandex Tracker

**Документация в README.md:**

```typescript
// В yandex-tracker/src/cli/config.ts
import { ConfigManager } from '@mcp-framework/cli';

interface YandexTrackerMCPConfig extends BaseMCPServerConfig {
  token: string;        // СЕКРЕТ - не сохраняется
  orgId: string;        // Безопасно - сохраняется
  apiBase?: string;     // Безопасно - сохраняется
  requestTimeout?: number;
}

const configManager = new ConfigManager<YandexTrackerMCPConfig>({
  projectName: 'fractalizer_mcp_yandex_tracker',

  // Список безопасных полей (БЕЗ token!)
  safeFields: ['orgId', 'apiBase', 'requestTimeout', 'logLevel', 'projectPath'],

  // Опционально: кастомная валидация
  deserialize: (data) => {
    // Проверить, что orgId существует и валиден
    if (typeof data.orgId === 'string' && data.orgId.length > 0) {
      return data as Partial<YandexTrackerMCPConfig>;
    }
    return undefined;
  },
});

// Использование
const saved = await configManager.load();
// saved = { orgId: '123', logLevel: 'info', ... }
// token НЕ сохранен и будет запрошен заново
```

### 4. Пример для другого MCP сервера

**В документации показать пример:**

```typescript
// Другой MCP сервер с API ключом вместо токена
interface CustomMCPConfig extends BaseMCPServerConfig {
  apiKey: string;           // СЕКРЕТ - не сохраняется
  endpoint: string;         // Безопасно - сохраняется
  cacheTTL?: number;        // Безопасно - сохраняется
}

const customConfigManager = new ConfigManager<CustomMCPConfig>({
  projectName: 'my_custom_mcp',
  safeFields: ['endpoint', 'cacheTTL', 'logLevel'],
});
```

---

## Тестирование

**Файл:** `tests/unit/utils/config-manager.test.ts`

```typescript
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { ConfigManager } from '../../../src/utils/config-manager.js';
import type { BaseMCPServerConfig } from '../../../src/types.js';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';

interface TestConfig extends BaseMCPServerConfig {
  token: string;      // секрет
  orgId: string;      // безопасно
}

describe('ConfigManager', () => {
  let configManager: ConfigManager<TestConfig>;
  let configPath: string;

  beforeEach(() => {
    configManager = new ConfigManager<TestConfig>({
      projectName: 'test_mcp_cli',
      safeFields: ['orgId', 'logLevel', 'projectPath'],
    });
    configPath = configManager.getConfigPath();
  });

  afterEach(async () => {
    // Cleanup
    try {
      await configManager.delete();
      const configDir = path.dirname(configPath);
      await fs.rmdir(configDir);
    } catch {
      // ignore
    }
  });

  it('should save only safe fields', async () => {
    const config: TestConfig = {
      token: 'secret-token',
      orgId: 'my-org',
      projectPath: '/test',
      logLevel: 'info',
    };

    await configManager.save(config);

    const loaded = await configManager.load();
    expect(loaded).toBeDefined();
    expect(loaded?.orgId).toBe('my-org');
    expect(loaded?.logLevel).toBe('info');
    expect('token' in (loaded ?? {})).toBe(false); // token не сохранен
  });

  it('should return undefined if config does not exist', async () => {
    const loaded = await configManager.load();
    expect(loaded).toBeUndefined();
  });

  it('should delete config', async () => {
    const config: TestConfig = {
      token: 'secret',
      orgId: 'org',
      projectPath: '/test',
    };

    await configManager.save(config);
    expect(await configManager.exists()).toBe(true);

    await configManager.delete();
    expect(await configManager.exists()).toBe(false);
  });
});
```

---

## Результат

- [x] `src/utils/config-manager.ts` создан
- [x] Generic типы работают корректно
- [x] Примеры использования в документации (JSDoc с примерами)
- [x] Unit тесты написаны и проходят (8 тестов)
- [x] `npm run validate` проходит

---

## Критерии готовности

- [x] ConfigManager работает с любым типом конфигурации
- [x] Секретные поля не сохраняются
- [x] Тесты покрывают основные сценарии
- [x] Документация с примерами готова
- [x] Нет зависимостей от yandex-tracker

**Этап 3.1 завершён ✅**
