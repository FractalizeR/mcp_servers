# 3.2 Generic InteractivePrompter

**Тип:** Parallel (можно выполнять одновременно с 3.1 и 3.3)
**Зависимости:** 2.3 Коннекторы
**Время:** ~1.5 часа

---

## Задача

Создать generic InteractivePrompter, который позволяет любому MCP серверу определить свои интерактивные промпты через декларативную конфигурацию.

**Ключевая идея:** Framework предоставляет механизм, а MCP сервер определяет содержание промптов.

---

## Действия

### 1. Создать типы для промптов

**Файл:** `src/utils/prompts.types.ts`

```typescript
/**
 * Тип промпта inquirer
 */
export type PromptType = 'input' | 'password' | 'list' | 'confirm' | 'number';

/**
 * Определение промпта для сбора конфигурации
 *
 * @template T - тип конфигурации
 * @template K - ключ поля в конфигурации
 */
export interface ConfigPromptDefinition<T, K extends keyof T = keyof T> {
  /** Имя поля в конфигурации */
  name: K;

  /** Тип промпта */
  type: PromptType;

  /** Сообщение пользователю */
  message: string;

  /**
   * Значение по умолчанию
   * Может быть статическим или функцией от сохраненной конфигурации
   */
  default?: T[K] | ((savedConfig?: Partial<T>) => T[K] | undefined);

  /**
   * Валидация введенного значения
   * Возвращает строку с ошибкой или true при успехе
   */
  validate?: (value: T[K]) => string | true | Promise<string | true>;

  /**
   * Варианты выбора (для type: 'list')
   */
  choices?: Array<{ name: string; value: T[K] }>;

  /**
   * Условное отображение промпта
   * Если возвращает false, промпт пропускается
   */
  when?: (answers: Partial<T>) => boolean;

  /**
   * Маска для password полей
   */
  mask?: string;
}
```

### 2. Создать InteractivePrompter класс

**Файл:** `src/utils/interactive-prompter.ts`

```typescript
import inquirer from 'inquirer';
import type { BaseMCPServerConfig, MCPClientInfo } from '../types.js';
import type { ConfigPromptDefinition } from './prompts.types.js';

/**
 * Generic интерактивный сборщик конфигурации
 */
export class InteractivePrompter<TConfig extends BaseMCPServerConfig> {
  /**
   * @param configPrompts - Определения промптов для конфигурации
   */
  constructor(private readonly configPrompts: ConfigPromptDefinition<TConfig>[]) {}

  /**
   * Собрать конфигурацию через интерактивные промпты
   *
   * @param savedConfig - Ранее сохраненная конфигурация (для defaults)
   * @returns Собранная конфигурация (без projectPath)
   */
  async promptServerConfig(savedConfig?: Partial<TConfig>): Promise<Omit<TConfig, 'projectPath'>> {
    const questions = this.configPrompts.map((prompt) => ({
      type: prompt.type,
      name: String(prompt.name),
      message: prompt.message,
      default:
        typeof prompt.default === 'function'
          ? () => prompt.default!(savedConfig)
          : prompt.default,
      validate: prompt.validate,
      choices: prompt.choices,
      when: prompt.when,
      mask: prompt.mask ?? (prompt.type === 'password' ? '*' : undefined),
    }));

    const answers = await inquirer.prompt(questions);
    return answers as Omit<TConfig, 'projectPath'>;
  }

  /**
   * Выбор клиента из списка
   */
  static async promptClientSelection(clients: MCPClientInfo[]): Promise<string> {
    const { selectedClient } = await inquirer.prompt<{ selectedClient: string }>([
      {
        type: 'list',
        name: 'selectedClient',
        message: 'Выберите MCP клиент для подключения:',
        choices: clients.map((client) => ({
          name: `${client.displayName} — ${client.description}`,
          value: client.name,
        })),
      },
    ]);

    return selectedClient;
  }

  /**
   * Подтверждение (yes/no)
   */
  static async promptConfirmation(message: string, defaultValue = true): Promise<boolean> {
    const { confirmed } = await inquirer.prompt<{ confirmed: boolean }>([
      {
        type: 'confirm',
        name: 'confirmed',
        message,
        default: defaultValue,
      },
    ]);

    return confirmed;
  }

  /**
   * Выбор из списка
   */
  static async promptSelection<T extends string>(
    message: string,
    choices: Array<{ name: string; value: T }>
  ): Promise<T> {
    const { selected } = await inquirer.prompt<{ selected: T }>([
      {
        type: 'list',
        name: 'selected',
        message,
        choices,
      },
    ]);

    return selected;
  }
}
```

### 3. Экспорт типов

**Обновить:** `src/utils/index.ts`

```typescript
export * from './prompts.types.js';
export * from './interactive-prompter.js';
export * from './config-manager.js';
// ... другие утилиты
```

### 4. Пример использования для Yandex Tracker

**В документации:**

```typescript
// yandex-tracker/src/cli/prompts.ts
import type { ConfigPromptDefinition } from '@mcp-framework/cli';
import type { YandexTrackerMCPConfig } from './types.js';

export const ytConfigPrompts: ConfigPromptDefinition<YandexTrackerMCPConfig>[] = [
  {
    name: 'token',
    type: 'password',
    message: 'OAuth токен Яндекс.Трекера:',
    mask: '*',
    validate: (value) => {
      if (!value || value.length === 0) {
        return 'Токен обязателен';
      }
      if (value.length < 10) {
        return 'Токен слишком короткий';
      }
      return true;
    },
  },
  {
    name: 'orgId',
    type: 'input',
    message: 'ID организации в Яндекс.Трекере:',
    default: (saved) => saved?.orgId,
    validate: (value) => {
      if (!value || value.length === 0) {
        return 'ID организации обязателен';
      }
      return true;
    },
  },
  {
    name: 'apiBase',
    type: 'input',
    message: 'Базовый URL API (необязательно):',
    default: (saved) => saved?.apiBase ?? 'https://api.tracker.yandex.net',
  },
  {
    name: 'logLevel',
    type: 'list',
    message: 'Уровень логирования:',
    choices: [
      { name: 'Debug (максимум деталей)', value: 'debug' },
      { name: 'Info (рекомендуется)', value: 'info' },
      { name: 'Warning (только предупреждения)', value: 'warn' },
      { name: 'Error (только ошибки)', value: 'error' },
    ],
    default: (saved) => saved?.logLevel ?? 'info',
  },
  {
    name: 'requestTimeout',
    type: 'number',
    message: 'Таймаут запросов (мс):',
    default: (saved) => saved?.requestTimeout ?? 30000,
    when: (answers) => {
      // Показывать только если выбран debug уровень
      return answers.logLevel === 'debug';
    },
  },
];

// Использование
const prompter = new InteractivePrompter(ytConfigPrompts);
const config = await prompter.promptServerConfig(savedConfig);
// config = { token: '...', orgId: '...', apiBase: '...', logLevel: 'info' }
```

### 5. Пример для другого MCP сервера

**В документации:**

```typescript
// Другой MCP сервер с API ключом
interface CustomMCPConfig extends BaseMCPServerConfig {
  apiKey: string;
  region: 'us' | 'eu' | 'asia';
  enableCache: boolean;
}

const customPrompts: ConfigPromptDefinition<CustomMCPConfig>[] = [
  {
    name: 'apiKey',
    type: 'password',
    message: 'Введите API ключ:',
    validate: (v) => v.length > 0 || 'API ключ обязателен',
  },
  {
    name: 'region',
    type: 'list',
    message: 'Выберите регион:',
    choices: [
      { name: 'США (US)', value: 'us' },
      { name: 'Европа (EU)', value: 'eu' },
      { name: 'Азия', value: 'asia' },
    ],
    default: 'us',
  },
  {
    name: 'enableCache',
    type: 'confirm',
    message: 'Включить кэширование?',
    default: true,
  },
];
```

---

## Тестирование

**Файл:** `tests/unit/utils/interactive-prompter.test.ts`

```typescript
import { describe, it, expect, vi } from 'vitest';
import { InteractivePrompter } from '../../../src/utils/interactive-prompter.js';
import type { ConfigPromptDefinition } from '../../../src/utils/prompts.types.js';
import type { BaseMCPServerConfig } from '../../../src/types.js';

interface TestConfig extends BaseMCPServerConfig {
  apiKey: string;
  endpoint: string;
}

describe('InteractivePrompter', () => {
  it('should create prompter with config definitions', () => {
    const prompts: ConfigPromptDefinition<TestConfig>[] = [
      {
        name: 'apiKey',
        type: 'password',
        message: 'API Key:',
      },
    ];

    const prompter = new InteractivePrompter(prompts);
    expect(prompter).toBeDefined();
  });

  // Note: полное тестирование inquirer сложно, нужны моки
  // Основные тесты - проверка типов и конфигурации
});
```

---

## Результат

- [ ] `src/utils/prompts.types.ts` создан
- [ ] `src/utils/interactive-prompter.ts` создан
- [ ] Generic типы работают корректно
- [ ] Примеры использования в документации
- [ ] Exports настроены
- [ ] Базовые тесты написаны
- [ ] `npm run validate` проходит

---

## Критерии готовности

- [ ] InteractivePrompter работает с любым типом конфигурации
- [ ] Декларативный подход к промптам
- [ ] Поддержка всех типов inquirer промптов
- [ ] Условная логика (when) работает
- [ ] Валидация поддерживается
- [ ] Документация с примерами готова
