# 3.2 Защита от коллизий имён в DI (P1, parallel)

**Execution type:** parallel (можно выполнять одновременно с 3.1)
**Priority:** P1 (высокий)

---

## Проблема

Автоматическая генерация Symbol токенов из имён классов может привести к коллизиям:

```typescript
// packages/servers/yandex-tracker/src/composition-root/types.ts
const toolSymbol = Symbol.for(ToolClass.name);  // "UpdateIssueTool"
const opSymbol = Symbol.for(OperationClass.name);  // "UpdateIssueOperation"
```

**Риски:**
1. Два класса с одинаковым именем → перезапись биндинга
2. Минификация может изменить имена непредсказуемо
3. Silent failures — DI не сообщит о проблеме

**Текущая защита:** Только валидация наличия имени, НЕТ проверки уникальности

---

## Цель

Добавить защиту от коллизий имён классов в DI системе.

---

## Решение: Namespace-based символы

### Вариант A: Namespace префиксы (рекомендуется)

```typescript
// Вместо Symbol.for("UpdateIssueTool")
// Использовать Symbol.for("tool:UpdateIssueTool")
```

**Плюсы:**
- Явное разделение namespaces (tool, operation, service)
- Меньше вероятность коллизий
- Более читаемые символы в отладке

### Вариант B: Runtime валидация уникальности

**Плюсы:**
- Ловит коллизии на старте приложения
- Не меняет формат символов

**Минусы:**
- Не защищает от минификации

**Рекомендация:** Комбинация A + B

---

## Шаги выполнения

### Шаг 1: Обновить генерацию символов

Отредактировать `packages/servers/yandex-tracker/src/composition-root/types.ts`:

```typescript
/**
 * Автоматическая генерация символов для Tools с namespace
 */
export const TOOL_SYMBOLS = TOOL_CLASSES.reduce(
  (acc, ToolClass) => {
    const className = ToolClass.name;
    if (!className || className === '') {
      throw new Error(
        `Tool class must have a valid name for DI registration. Got: ${String(ToolClass)}`
      );
    }

    // Namespace prefix для избежания коллизий
    const symbolKey = `tool:${className}`;
    const symbol = Symbol.for(symbolKey);

    acc[className] = symbol;
    return acc;
  },
  {} as Record<string, symbol>
);

/**
 * Автоматическая генерация символов для Operations с namespace
 */
export const OPERATION_SYMBOLS = OPERATION_CLASSES.reduce(
  (acc, OperationClass) => {
    const className = OperationClass.name;
    if (!className || className === '') {
      throw new Error(
        `Operation class must have a valid name for DI registration. Got: ${String(OperationClass)}`
      );
    }

    // Namespace prefix для избежания коллизий
    const symbolKey = `operation:${className}`;
    const symbol = Symbol.for(symbolKey);

    acc[className] = symbol;
    return acc;
  },
  {} as Record<string, symbol>
);
```

### Шаг 2: Добавить runtime валидацию уникальности

Создать `packages/servers/yandex-tracker/src/composition-root/validation.ts`:

```typescript
/**
 * Валидация уникальности имён классов
 */
export function validateUniqueClassNames(
  classes: Array<new (...args: any[]) => any>,
  type: 'Tool' | 'Operation'
): void {
  const names = new Set<string>();
  const duplicates: string[] = [];

  for (const ClassDef of classes) {
    const name = ClassDef.name;
    if (names.has(name)) {
      duplicates.push(name);
    }
    names.add(name);
  }

  if (duplicates.length > 0) {
    throw new Error(
      `Duplicate ${type} class names detected: ${duplicates.join(', ')}. ` +
      `Each ${type} must have a unique name for DI registration.`
    );
  }
}

/**
 * Валидация всех DI регистраций
 */
export function validateDIRegistrations(): void {
  const { TOOL_CLASSES } = require('./definitions/tool-definitions.js');
  const { OPERATION_CLASSES } = require('./definitions/operation-definitions.js');

  validateUniqueClassNames(TOOL_CLASSES, 'Tool');
  validateUniqueClassNames(OPERATION_CLASSES, 'Operation');
}
```

### Шаг 3: Вызвать валидацию при создании контейнера

Отредактировать `packages/servers/yandex-tracker/src/composition-root/container.ts`:

```typescript
import { validateDIRegistrations } from './validation.js';

/**
 * Создание и конфигурация DI контейнера
 */
export function createContainer(config: ServerConfig): Container {
  // Валидация перед созданием контейнера
  validateDIRegistrations();

  const container = new Container({
    defaultScope: 'Singleton',
  });

  // ... остальной код
}
```

### Шаг 4: Обновить регистрацию в контейнере

Убедиться, что используются новые TOOL_SYMBOLS и OPERATION_SYMBOLS:

```typescript
// Регистрация Operations
for (const OperationClass of OPERATION_CLASSES) {
  const className = OperationClass.name;
  const symbol = OPERATION_SYMBOLS[className];

  if (!symbol) {
    throw new Error(`Symbol not found for operation: ${className}`);
  }

  container.bind(symbol).toDynamicValue(() => {
    // ... создание instance
  });
}
```

### Шаг 5: Добавить логирование символов при старте

Отредактировать `container.ts`:

```typescript
export function createContainer(config: ServerConfig): Container {
  validateDIRegistrations();

  const container = new Container({
    defaultScope: 'Singleton',
  });

  // ... регистрация сервисов

  // Логирование зарегистрированных символов
  const logger = container.get<Logger>(TYPES.Logger);
  logger.debug({
    toolSymbols: Object.keys(TOOL_SYMBOLS),
    operationSymbols: Object.keys(OPERATION_SYMBOLS),
  }, 'DI symbols registered');

  return container;
}
```

### Шаг 6: Добавить тесты

Создать `packages/servers/yandex-tracker/tests/unit/composition-root/validation.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { validateUniqueClassNames } from '#composition-root/validation.js';

describe('DI Validation', () => {
  it('should pass for unique class names', () => {
    class Tool1 {}
    class Tool2 {}

    expect(() => {
      validateUniqueClassNames([Tool1, Tool2], 'Tool');
    }).not.toThrow();
  });

  it('should throw for duplicate class names', () => {
    class DuplicateTool {}
    class DuplicateTool {} // eslint-disable-line @typescript-eslint/no-redeclare

    // Примечание: В реальности два класса с одинаковым именем невозможны
    // в одном scope, но можем эмулировать через Object.defineProperty

    const Tool1 = class {};
    const Tool2 = class {};
    Object.defineProperty(Tool1, 'name', { value: 'SameName' });
    Object.defineProperty(Tool2, 'name', { value: 'SameName' });

    expect(() => {
      validateUniqueClassNames([Tool1, Tool2], 'Tool');
    }).toThrow('Duplicate Tool class names detected: SameName');
  });

  it('should validate all DI registrations on container creation', () => {
    // Этот тест проверяет, что реальные определения валидны
    expect(() => {
      const { validateDIRegistrations } = require('#composition-root/validation.js');
      validateDIRegistrations();
    }).not.toThrow();
  });
});
```

### Шаг 7: Обновить документацию

Добавить в `packages/servers/yandex-tracker/src/composition-root/README.md`:

```markdown
## Защита от коллизий имён

DI система автоматически генерирует символы из имён классов с namespace префиксами:

```typescript
Symbol.for("tool:GetIssuesTool")
Symbol.for("operation:GetIssuesOperation")
```

### Валидация при старте

При создании контейнера автоматически проверяется уникальность имён:

```typescript
// Это вызовет ошибку при старте, если есть дубликаты
validateDIRegistrations();
```

### Best Practices

1. ✅ **Уникальные имена:** Каждый Tool/Operation должен иметь уникальное имя
2. ✅ **Избегать минификации:** Не минифицировать production build (или использовать keep_classnames)
3. ✅ **Namespace separation:** tool:* и operation:* не могут конфликтовать

### Обработка ошибок

Если валидация не проходит:

```
Error: Duplicate Tool class names detected: UpdateIssueTool.
Each Tool must have a unique name for DI registration.
```

**Решение:** Переименовать один из классов.
```

---

## Проверка результатов

### Автоматические тесты
```bash
npm run test -- validation.test.ts
npm run validate
```

### Ручная проверка символов
```bash
# Запустить сервер с DEBUG логами
LOG_LEVEL=debug npm start

# Проверить в логах:
# "DI symbols registered" { toolSymbols: [...], operationSymbols: [...] }
```

### Проверка уникальности (негативный тест)

Временно создать дубликат:

```typescript
// В tool-definitions.ts
export const TOOL_CLASSES = [
  GetIssuesTool,
  GetIssuesTool,  // дубликат
  // ...
];
```

Запустить:
```bash
npm start
# Должна быть ошибка: "Duplicate Tool class names detected: GetIssuesTool"
```

Откатить изменения.

---

## Критерий готовности (Definition of Done)

- ✅ Символы генерируются с namespace префиксами (types.ts)
- ✅ Функция validateUniqueClassNames добавлена (validation.ts)
- ✅ validateDIRegistrations вызывается при создании контейнера (container.ts:285)
- ✅ Логирование символов при старте (container.ts:324-329)
- ✅ Тесты добавлены и проходят (tests/composition-root/validation.test.ts)
- ✅ Негативный тест проверен (тесты покрывают дублирование)
- ✅ README.md обновлён (раздел "Защита от коллизий имён")
- ✅ `npm run validate` проходит (149 файлов, 1928 тестов)
- ⏳ Коммит создан

## Результаты выполнения

**Дата:** 2025-11-22
**Статус:** ✅ Выполнено успешно

**Изменённые файлы:**
- `src/composition-root/types.ts` — добавлены namespace префиксы
- `src/composition-root/validation.ts` — новый файл с валидацией
- `src/composition-root/container.ts` — вызов валидации и логирование
- `src/composition-root/README.md` — документация
- `tests/composition-root/validation.test.ts` — новый файл с тестами

**Логирование при старте:**
```json
{
  "toolSymbols": ["PingTool", "GetIssuesTool", ...],
  "operationSymbols": ["PingOperation", "GetIssuesOperation", ...],
  "totalTools": 41,
  "totalOperations": 61,
  "msg": "DI symbols registered successfully"
}
```

**Следующие шаги:** Создать коммит с изменениями
