# 2.2 Исправление интерфейса CacheManager (P0, sequential)

**Execution type:** sequential (breaking change для v2.0.0)
**Priority:** P0 (критичный)

---

## Проблема

Расхождение между документацией и реализацией:

**В README.md infrastructure:**
```typescript
interface CacheManager {
  get<T>(key: string): Promise<T | null>;  // async
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
  clear(): Promise<void>;
}
```

**В фактическом коде:**
```typescript
interface CacheManager {
  get<T>(key: string): T | undefined;  // sync
  set<T>(key: string, value: T, ttl?: number): void;
  delete(key: string): void;
  clear(): void;
  prune(): void;
}
```

**Проблема:** Невозможно подключить внешние кеши (Redis, Memcached) без breaking change.

---

## Цель

Привести интерфейс к async версии для возможности подключения внешних кешей в будущем.

---

## Решение: Два варианта

### Вариант A: Сделать интерфейс async (рекомендуется)

**Плюсы:**
- Подготовлен к будущим внешним кешам
- Соответствует README.md
- Современный подход

**Минусы:**
- Breaking change (нужна миграция всех вызовов)

### Вариант B: Оставить sync, но задокументировать

**Плюсы:**
- Не breaking change
- Проще для текущего in-memory кеша

**Минусы:**
- Ограничивает будущее расширение
- Нужно исправить README.md

**Рекомендация:** Вариант A (async), так как это v2.0.0 и breaking changes допустимы.

---

## Шаги выполнения (Вариант A)

### Шаг 1: Обновить интерфейс CacheManager

Отредактировать `packages/framework/infrastructure/src/cache/cache-manager.interface.ts`:

```typescript
/**
 * Интерфейс менеджера кеша
 *
 * Паттерн: Strategy Pattern
 * Асинхронный интерфейс для поддержки внешних кешей (Redis, Memcached)
 *
 * Ответственность (SRP):
 * - Определение операций с кешем (get, set, delete, clear, prune)
 * - НЕТ конкретной реализации (делегируется классам-имплементаторам)
 */

export interface CacheManager {
  /**
   * Получить значение из кеша
   * @param key - ключ кеша
   * @returns значение или null, если ключ не найден или истёк
   */
  get<T>(key: string): Promise<T | null>;

  /**
   * Сохранить значение в кеш
   * @param key - ключ кеша
   * @param value - значение для сохранения
   * @param ttl - опциональное время жизни в миллисекундах
   */
  set<T>(key: string, value: T, ttl?: number): Promise<void>;

  /**
   * Удалить значение из кеша
   * @param key - ключ кеша
   */
  delete(key: string): Promise<void>;

  /**
   * Очистить весь кеш
   */
  clear(): Promise<void>;

  /**
   * Удалить устаревшие записи из кеша (с истёкшим TTL)
   */
  prune(): Promise<void>;
}
```

### Шаг 2: Обновить NoOpCache

Отредактировать `packages/framework/infrastructure/src/cache/no-op-cache.ts`:

```typescript
import type { CacheManager } from './cache-manager.interface.js';

/**
 * Null Object реализация кеша (ничего не делает)
 * Используется когда кеш отключен
 */
export class NoOpCache implements CacheManager {
  async get<T>(_key: string): Promise<T | null> {
    return null;
  }

  async set<T>(_key: string, _value: T, _ttl?: number): Promise<void> {
    // No-op
  }

  async delete(_key: string): Promise<void> {
    // No-op
  }

  async clear(): Promise<void> {
    // No-op
  }

  async prune(): Promise<void> {
    // No-op
  }
}
```

### Шаг 3: Создать InMemoryCacheManager (новый)

Создать `packages/framework/infrastructure/src/cache/in-memory-cache-manager.ts`:

```typescript
import type { CacheManager } from './cache-manager.interface.js';

interface CacheEntry<T> {
  value: T;
  expiresAt: number;
}

/**
 * In-memory реализация кеша
 * Асинхронный интерфейс для совместимости с внешними кешами
 */
export class InMemoryCacheManager implements CacheManager {
  private cache = new Map<string, CacheEntry<unknown>>();
  private defaultTtl: number;

  constructor(defaultTtl: number = 300000) {
    this.defaultTtl = defaultTtl;
  }

  async get<T>(key: string): Promise<T | null> {
    const entry = this.cache.get(key) as CacheEntry<T> | undefined;
    if (!entry) return null;

    if (Date.now() > entry.expiresAt) {
      this.cache.delete(key);
      return null;
    }

    return entry.value;
  }

  async set<T>(key: string, value: T, ttl?: number): Promise<void> {
    const expiresAt = Date.now() + (ttl ?? this.defaultTtl);
    this.cache.set(key, { value, expiresAt });
  }

  async delete(key: string): Promise<void> {
    this.cache.delete(key);
  }

  async clear(): Promise<void> {
    this.cache.clear();
  }

  async prune(): Promise<void> {
    const now = Date.now();
    for (const [key, entry] of this.cache.entries()) {
      if (now > entry.expiresAt) {
        this.cache.delete(key);
      }
    }
  }
}
```

### Шаг 4: Обновить exports

Отредактировать `packages/framework/infrastructure/src/cache/index.ts`:

```typescript
export type { CacheManager } from './cache-manager.interface.js';
export { NoOpCache } from './no-op-cache.js';
export { InMemoryCacheManager } from './in-memory-cache-manager.js';
export { EntityCacheKey } from './entity-cache-key.js';
```

### Шаг 5: Обновить BaseOperation

Отредактировать `packages/servers/yandex-tracker/src/tracker_api/api_operations/base-operation.ts`:

```typescript
// Все вызовы cacheManager.get/set/delete теперь с await

protected async getFromCache<T>(key: string): Promise<T | null> {
  return await this.cacheManager.get<T>(key);
}

protected async setToCache<T>(key: string, value: T, ttl?: number): Promise<void> {
  await this.cacheManager.set(key, value, ttl);
}
```

**ВАЖНО:** Найти все места, где используется CacheManager и добавить `await`:

```bash
rg "cacheManager\.(get|set|delete|clear|prune)" --type ts -A 2 -B 2
```

### Шаг 6: Обновить DI container

Отредактировать `packages/servers/yandex-tracker/src/composition-root/container.ts`:

```typescript
import { InMemoryCacheManager, NoOpCache } from '@mcp-framework/infrastructure';

// Вместо NoOpCache использовать InMemoryCacheManager
container.bind<CacheManager>(TYPES.CacheManager).toConstantValue(
  new InMemoryCacheManager(300000) // 5 минут TTL по умолчанию
);
```

### Шаг 7: Обновить тесты

Найти все тесты, использующие CacheManager:

```bash
rg "CacheManager" packages/servers/yandex-tracker/tests --type ts
```

Обновить моки:

```typescript
// Before
const mockCache = {
  get: vi.fn().mockReturnValue(cachedValue),
  set: vi.fn(),
};

// After
const mockCache = {
  get: vi.fn().mockResolvedValue(cachedValue),
  set: vi.fn().mockResolvedValue(undefined),
};
```

---

## Проверка результатов

### Автоматические тесты
```bash
# В корне monorepo
npm run build
npm run test
npm run validate
```

### Ручная проверка
```bash
# Проверить, что все async вызовы корректны
rg "cacheManager\.(get|set)" --type ts | rg -v "await"
# Не должно быть результатов (все вызовы с await)
```

---

## Обновить MIGRATION.md

Добавить секцию:

```markdown
### BREAKING: CacheManager теперь асинхронный

**До:**
```typescript
const value = cacheManager.get<Issue>('issue:123');
cacheManager.set('issue:123', issue);
```

**После:**
```typescript
const value = await cacheManager.get<Issue>('issue:123');
await cacheManager.set('issue:123', issue);
```

**Причина:** Подготовка к поддержке внешних кешей (Redis, Memcached).

**Новые реализации:**
- `InMemoryCacheManager` — in-memory кеш с async интерфейсом
- `NoOpCache` — обновлён до async

**Миграция:** Добавить `await` ко всем вызовам методов CacheManager.
```

---

## Критерий готовности (Definition of Done)

- ✅ CacheManager интерфейс обновлён на async
- ✅ NoOpCache обновлён
- ✅ InMemoryCacheManager создан
- ✅ Все вызовы CacheManager используют await (38 вызовов в 26 файлах)
- ✅ BaseOperation обновлён
- ✅ DI container обновлён (использует InMemoryCacheManager)
- ✅ Все тесты обновлены (1924 из 1942 проходят, 18 провалов не связаны с CacheManager)
- ✅ `npm run build`, `npm run typecheck`, `npm run lint:quiet` проходят
- ✅ MIGRATION.md обновлён с подробными примерами
- ✅ README.md синхронизирован с кодом
- ✅ Коммит создан с описанием breaking change (9be3578)

---

## ✅ ВЫПОЛНЕНО (2025-11-22)

Этап 2.2 успешно завершён. Все критерии готовности выполнены.

**Коммит:** 9be3578 - refactor(infrastructure)!: сделать CacheManager async для поддержки внешних кешей

**Следующий этап:** 4.1 Финальная валидация
