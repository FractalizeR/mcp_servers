# Этап 6.1: Тестирование и Документация (parallel)

**Тип выполнения:** parallel
**Причина:** Тесты и документация независимы друг от друга
**Зависимости:** Этап 5.1 завершён

---

## Тестирование

### 6.1.1. Структура тестов

```
tests/
├── unit/
│   ├── operations/
│   │   ├── projects/
│   │   │   ├── get-projects.operation.test.ts
│   │   │   └── ...
│   │   └── tasks/
│   │       └── ...
│   ├── tools/
│   │   ├── projects/
│   │   └── tasks/
│   └── utils/
├── integration/
│   ├── facade.test.ts
│   └── oauth.test.ts
└── smoke/
    └── server.smoke.test.ts
```

### 6.1.2. Unit тесты для Operations

```typescript
// tests/unit/operations/projects/get-projects.operation.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GetProjectsOperation } from '#ticktick_api/api_operations/projects/get-projects.operation.js';

describe('GetProjectsOperation', () => {
  let operation: GetProjectsOperation;
  let mockHttpClient: MockHttpClient;
  let mockCacheManager: MockCacheManager;

  beforeEach(() => {
    mockHttpClient = createMockHttpClient();
    mockCacheManager = createMockCacheManager();
    operation = new GetProjectsOperation(mockHttpClient, mockCacheManager, mockLogger);
  });

  it('should fetch projects from API', async () => {
    const mockProjects = [
      { id: '1', name: 'Project 1' },
      { id: '2', name: 'Project 2' },
    ];
    mockHttpClient.get.mockResolvedValue(mockProjects);

    const result = await operation.execute();

    expect(result).toEqual(mockProjects);
    expect(mockHttpClient.get).toHaveBeenCalledWith('/project');
  });

  it('should use cache when available', async () => {
    const cachedProjects = [{ id: '1', name: 'Cached' }];
    mockCacheManager.get.mockReturnValue(cachedProjects);

    const result = await operation.execute();

    expect(result).toEqual(cachedProjects);
    expect(mockHttpClient.get).not.toHaveBeenCalled();
  });

  it('should cache results after fetch', async () => {
    const mockProjects = [{ id: '1', name: 'New' }];
    mockHttpClient.get.mockResolvedValue(mockProjects);
    mockCacheManager.get.mockReturnValue(undefined);

    await operation.execute();

    expect(mockCacheManager.set).toHaveBeenCalledWith('projects:all', mockProjects);
  });
});
```

### 6.1.3. Unit тесты для Tools

```typescript
// tests/unit/tools/projects/get-projects.tool.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { GetProjectsTool } from '#tools/api/projects/get-projects/get-projects.tool.js';

describe('GetProjectsTool', () => {
  let tool: GetProjectsTool;
  let mockFacade: MockTickTickFacade;

  beforeEach(() => {
    mockFacade = createMockFacade();
    tool = new GetProjectsTool(mockFacade, mockLogger);
  });

  it('should return filtered projects', async () => {
    const mockProjects = [
      { id: '1', name: 'Project 1', color: '#ff0000', viewMode: 'list' },
      { id: '2', name: 'Project 2', color: '#00ff00', viewMode: 'kanban' },
    ];
    mockFacade.getProjects.mockResolvedValue(mockProjects);

    const result = await tool.execute({ fields: ['id', 'name'] });

    expect(result.projects).toEqual([
      { id: '1', name: 'Project 1' },
      { id: '2', name: 'Project 2' },
    ]);
    expect(result.fieldsReturned).toEqual(['id', 'name']);
  });

  it('should validate params', async () => {
    await expect(tool.execute({})).rejects.toThrow();
    await expect(tool.execute({ fields: [] })).rejects.toThrow();
  });
});
```

### 6.1.4. Integration тесты

```typescript
// tests/integration/facade.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { createContainer } from '#composition-root/container.js';
import { TYPES } from '#composition-root/types.js';
import type { TickTickFacade } from '#ticktick_api/facade/ticktick.facade.js';

describe('TickTickFacade Integration', () => {
  let facade: TickTickFacade;

  beforeAll(() => {
    // Используем тестовые токены
    process.env.TICKTICK_ACCESS_TOKEN = 'test_token';
    const container = createContainer();
    facade = container.get(TYPES.TickTickFacade);
  });

  it('should get projects', async () => {
    const projects = await facade.getProjects();
    expect(Array.isArray(projects)).toBe(true);
  });

  it('should handle getAllTasks', async () => {
    const tasks = await facade.getAllTasks();
    expect(Array.isArray(tasks)).toBe(true);
  });
});
```

### 6.1.5. Smoke тесты

```typescript
// tests/smoke/server.smoke.test.ts
import { describe, it, expect } from 'vitest';
import { spawn } from 'child_process';

describe('MCP Server Smoke Tests', () => {
  it('should start without errors', async () => {
    const server = spawn('node', ['dist/index.js'], {
      env: {
        ...process.env,
        TICKTICK_ACCESS_TOKEN: 'test_token',
      },
    });

    await new Promise((resolve) => setTimeout(resolve, 2000));

    expect(server.exitCode).toBeNull(); // Still running
    server.kill();
  });

  it('should respond to tools/list', async () => {
    // Используем MCP client для проверки
    // ...
  });
});
```

### 6.1.6. Конфигурация Vitest

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    include: ['tests/**/*.test.ts'],
    coverage: {
      provider: 'v8',
      reporter: ['text', 'lcov'],
      thresholds: {
        lines: 80,
        functions: 80,
        branches: 70,
        statements: 80,
      },
    },
  },
  resolve: {
    alias: {
      '#ticktick_api': path.resolve(__dirname, './src/ticktick_api'),
      '#tools': path.resolve(__dirname, './src/tools'),
      '#composition-root': path.resolve(__dirname, './src/composition-root'),
      '#config': path.resolve(__dirname, './src/config'),
      '#constants': path.resolve(__dirname, './src/constants.ts'),
    },
  },
});
```

---

## Документация

### 6.1.7. README.md

```markdown
# TickTick MCP Server

MCP сервер для интеграции TickTick (todo-list приложения) с Claude и другими MCP клиентами.

## Особенности

- **25 инструментов** для работы с проектами и задачами
- **Фильтрация полей** — экономия 80-90% контекста
- **Параллельные запросы** — до 5 одновременных (ParallelExecutor)
- **Отключение групп** — DISABLED_TOOL_GROUPS
- **Lazy/Eager режимы** — TOOL_DISCOVERY_MODE
- **Кеширование** — 5 минут TTL
- **OAuth 2.0** с автоматическим refresh
- **Поддержка Dida365** (китайская версия)

## Установка

\`\`\`bash
npm install @mcp-server/ticktick
\`\`\`

## Настройка

### 1. Создайте приложение в TickTick Developer Portal

1. Перейдите на https://developer.ticktick.com/
2. Создайте новое приложение
3. Скопируйте Client ID и Client Secret

### 2. Настройте переменные окружения

\`\`\`bash
# OAuth
TICKTICK_CLIENT_ID=your_client_id
TICKTICK_CLIENT_SECRET=your_client_secret
TICKTICK_REDIRECT_URI=http://localhost:3000/callback

# Или используйте готовые токены
TICKTICK_ACCESS_TOKEN=your_access_token
TICKTICK_REFRESH_TOKEN=your_refresh_token
\`\`\`

### 3. Аутентификация

\`\`\`bash
npx ticktick-mcp-cli login
\`\`\`

## Использование

### Claude Desktop

\`\`\`json
{
  "mcpServers": {
    "ticktick": {
      "command": "npx",
      "args": ["@mcp-server/ticktick"],
      "env": {
        "TICKTICK_ACCESS_TOKEN": "your_token"
      }
    }
  }
}
\`\`\`

## Инструменты

### Projects
| Tool | Описание |
|------|----------|
| get_projects | Получить все проекты |
| get_project | Получить проект по ID |
| get_project_tasks | Получить задачи проекта |
| create_project | Создать проект |
| update_project | Обновить проект |
| delete_project | Удалить проект |

### Tasks
| Tool | Описание |
|------|----------|
| get_task | Получить задачу |
| get_tasks | Получить несколько задач (batch) |
| get_all_tasks | Все задачи пользователя |
| search_tasks | Поиск по тексту |
| create_task | Создать задачу |
| batch_create_tasks | Массовое создание |
| update_task | Обновить задачу |
| complete_task | Завершить задачу |
| delete_task | Удалить задачу |

### Date Queries
| Tool | Описание |
|------|----------|
| get_tasks_due_today | Срок сегодня |
| get_tasks_due_tomorrow | Срок завтра |
| get_tasks_due_in_days | Срок в N дней |
| get_tasks_due_this_week | Срок на неделе |
| get_overdue_tasks | Просроченные |

### Helpers
| Tool | Описание |
|------|----------|
| ping | Проверка подключения |
| search_tools | Поиск инструментов |
| get_engaged_tasks | GTD: горящие |
| get_next_tasks | GTD: следующие |

## Конфигурация

\`\`\`bash
# Только чтение
ENABLED_TOOL_CATEGORIES="tasks:read,projects:read,helpers"

# Отключить GTD
DISABLED_TOOL_GROUPS="helpers:gtd"

# Lazy mode
TOOL_DISCOVERY_MODE=lazy
\`\`\`

## Для Dida365

\`\`\`bash
TICKTICK_API_BASE_URL=https://api.dida365.com/open/v1
\`\`\`
```

### 6.1.8. CLAUDE.md

```markdown
# CLAUDE.md — TickTick MCP

## Критические правила

### Граф зависимостей
\`\`\`
infrastructure (база)
    ↓
core (BaseTool, types)
    ↓
search (ToolSearchEngine)
    ↓
ticktick (этот пакет)
\`\`\`

### Импорты
- Между пакетами: `@mcp-framework/core`
- Внутри пакета: `#ticktick_api/*`, `#tools/*`

### Добавление Tool

1. Создать файлы в `src/tools/api/{category}/{action}/`:
   - `{name}.schema.ts`
   - `{name}.metadata.ts`
   - `{name}.tool.ts`
   - `index.ts`

2. Добавить в `tool-definitions.ts`:
   \`\`\`typescript
   import { NewTool } from '#tools/api/...';
   export const TOOL_CLASSES = [..., NewTool];
   \`\`\`

3. Запустить валидацию:
   \`\`\`bash
   npm run validate:quiet
   \`\`\`

### Обязательные параметры Tool

- `fields` — для GET операций (экономия контекста)
- Используй `ResponseFieldFilter.filter(data, fields)`

### Категоризация

\`\`\`typescript
{
  category: 'tasks' | 'projects' | 'helpers',
  subcategory: 'read' | 'write' | 'date' | 'gtd' | undefined,
  priority: 'critical' | 'high' | 'normal' | 'low',
}
\`\`\`
```

---

## Валидация

```bash
npm run test
npm run test:coverage
npm run validate
```

---

## Чек-лист завершения

- [ ] Unit тесты для operations (coverage > 80%)
- [ ] Unit тесты для tools (coverage > 80%)
- [ ] Integration тесты работают
- [ ] Smoke тесты проходят
- [ ] README.md создан
- [ ] CLAUDE.md создан
- [ ] `npm run validate` проходит
