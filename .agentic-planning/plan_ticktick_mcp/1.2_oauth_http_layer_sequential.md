# Этап 1.2: OAuth и HTTP слой (sequential)

**Тип выполнения:** sequential (один агент)
**Причина:** HTTP клиент зависит от OAuth, OAuth зависит от конфигурации
**Зависимости:** Этап 1.1 завершён

---

## Задачи

### 1.2.1. Создать OAuth 2.0 клиент
- [ ] Класс для управления токенами
- [ ] Автоматическое обновление access token
- [ ] Кеширование токенов

```typescript
// src/ticktick_api/auth/oauth-client.ts
import type { OAuthConfig } from '#config/server-config.interface.js';
import type { IHttpClient } from '@mcp-framework/infrastructure';

export interface TokenPair {
  accessToken: string;
  refreshToken: string;
  expiresAt: number;
}

export class TickTickOAuthClient {
  private tokenPair: TokenPair | null = null;
  private readonly tokenEndpoint = 'https://ticktick.com/oauth/token';

  constructor(
    private readonly config: OAuthConfig,
    private readonly httpClient: IHttpClient
  ) {
    // Инициализация из конфига если токены есть
    if (config.accessToken) {
      this.tokenPair = {
        accessToken: config.accessToken,
        refreshToken: config.refreshToken ?? '',
        expiresAt: Date.now() + 6 * 30 * 24 * 60 * 60 * 1000, // ~6 месяцев
      };
    }
  }

  async getAccessToken(): Promise<string> {
    if (!this.tokenPair) {
      throw new Error('Not authenticated. Call authenticate() first.');
    }

    // Проверка истечения (за 5 минут до)
    if (this.tokenPair.expiresAt - Date.now() < 5 * 60 * 1000) {
      await this.refreshAccessToken();
    }

    return this.tokenPair.accessToken;
  }

  async refreshAccessToken(): Promise<void> {
    if (!this.tokenPair?.refreshToken) {
      throw new Error('No refresh token available');
    }

    const response = await this.httpClient.post(this.tokenEndpoint, {
      grant_type: 'refresh_token',
      client_id: this.config.clientId,
      client_secret: this.config.clientSecret,
      refresh_token: this.tokenPair.refreshToken,
    });

    this.tokenPair = {
      accessToken: response.access_token,
      refreshToken: response.refresh_token ?? this.tokenPair.refreshToken,
      expiresAt: Date.now() + (response.expires_in ?? 15552000) * 1000,
    };
  }

  getAuthorizationUrl(scopes: string[] = ['tasks:read', 'tasks:write']): string {
    const params = new URLSearchParams({
      client_id: this.config.clientId,
      redirect_uri: this.config.redirectUri,
      response_type: 'code',
      scope: scopes.join(' '),
    });
    return `https://ticktick.com/oauth/authorize?${params}`;
  }

  async exchangeCodeForToken(code: string): Promise<TokenPair> {
    const response = await this.httpClient.post(this.tokenEndpoint, {
      grant_type: 'authorization_code',
      client_id: this.config.clientId,
      client_secret: this.config.clientSecret,
      code,
      redirect_uri: this.config.redirectUri,
    });

    this.tokenPair = {
      accessToken: response.access_token,
      refreshToken: response.refresh_token,
      expiresAt: Date.now() + (response.expires_in ?? 15552000) * 1000,
    };

    return this.tokenPair;
  }

  isAuthenticated(): boolean {
    return this.tokenPair !== null;
  }
}
```

### 1.2.2. Создать authenticated HTTP клиент
- [ ] Обёртка над базовым HttpClient из infrastructure
- [ ] Автоматическое добавление Authorization header
- [ ] Интеграция с OAuth клиентом

```typescript
// src/ticktick_api/http/authenticated-http-client.ts
import type { IHttpClient, HttpRequestConfig } from '@mcp-framework/infrastructure';
import type { TickTickOAuthClient } from '../auth/oauth-client.js';

export class AuthenticatedHttpClient implements IHttpClient {
  constructor(
    private readonly baseClient: IHttpClient,
    private readonly oauthClient: TickTickOAuthClient,
    private readonly baseUrl: string
  ) {}

  private async getAuthHeaders(): Promise<Record<string, string>> {
    const token = await this.oauthClient.getAccessToken();
    return {
      Authorization: `Bearer ${token}`,
      'Content-Type': 'application/json',
    };
  }

  private resolveUrl(endpoint: string): string {
    return endpoint.startsWith('http') ? endpoint : `${this.baseUrl}${endpoint}`;
  }

  async get<T>(endpoint: string, config?: HttpRequestConfig): Promise<T> {
    const headers = await this.getAuthHeaders();
    return this.baseClient.get(this.resolveUrl(endpoint), {
      ...config,
      headers: { ...headers, ...config?.headers },
    });
  }

  async post<T>(endpoint: string, data?: unknown, config?: HttpRequestConfig): Promise<T> {
    const headers = await this.getAuthHeaders();
    return this.baseClient.post(this.resolveUrl(endpoint), data, {
      ...config,
      headers: { ...headers, ...config?.headers },
    });
  }

  async put<T>(endpoint: string, data?: unknown, config?: HttpRequestConfig): Promise<T> {
    const headers = await this.getAuthHeaders();
    return this.baseClient.put(this.resolveUrl(endpoint), data, {
      ...config,
      headers: { ...headers, ...config?.headers },
    });
  }

  async delete<T>(endpoint: string, config?: HttpRequestConfig): Promise<T> {
    const headers = await this.getAuthHeaders();
    return this.baseClient.delete(this.resolveUrl(endpoint), {
      ...config,
      headers: { ...headers, ...config?.headers },
    });
  }
}
```

### 1.2.3. Интегрировать с infrastructure пакетом
- [ ] Использовать HttpClientFactory для создания base client
- [ ] Настроить retry strategy
- [ ] Интегрировать CacheManager

```typescript
// src/composition-root/bindings/http-bindings.ts
import { Container } from 'inversify';
import { HttpClientFactory, InMemoryCacheManager } from '@mcp-framework/infrastructure';
import { TickTickOAuthClient } from '#ticktick_api/auth/oauth-client.js';
import { AuthenticatedHttpClient } from '#ticktick_api/http/authenticated-http-client.js';
import { TYPES } from '../types.js';
import type { ServerConfig } from '#config/server-config.interface.js';

export function bindHttpLayer(container: Container, config: ServerConfig): void {
  // Base HTTP client с retry
  const baseHttpClient = HttpClientFactory.create({
    retryAttempts: config.retry.attempts,
    retryMinDelay: config.retry.minDelay,
    retryMaxDelay: config.retry.maxDelay,
  });

  // OAuth client
  const oauthClient = new TickTickOAuthClient(config.oauth, baseHttpClient);
  container.bind(TYPES.OAuthClient).toConstantValue(oauthClient);

  // Authenticated HTTP client
  const authHttpClient = new AuthenticatedHttpClient(
    baseHttpClient,
    oauthClient,
    config.api.baseUrl
  );
  container.bind(TYPES.HttpClient).toConstantValue(authHttpClient);

  // Cache manager
  const cacheManager = new InMemoryCacheManager(config.cache.ttlMs);
  container.bind(TYPES.CacheManager).toConstantValue(cacheManager);
}
```

---

## Валидация

```bash
npm run typecheck
npm run lint
```

---

## Чек-лист завершения

- [ ] TickTickOAuthClient работает с токенами
- [ ] AuthenticatedHttpClient добавляет Authorization header
- [ ] Retry strategy настроена через infrastructure
- [ ] CacheManager интегрирован
- [ ] DI bindings для HTTP слоя созданы
- [ ] `npm run typecheck` проходит
