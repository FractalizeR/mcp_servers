# Этап 3.1: Facade и DI Container (sequential)

**Тип выполнения:** sequential
**Причина:** Facade зависит от всех operations, DI связывает все компоненты
**Зависимости:** Этапы 2.1, 2.2 завершены

---

## Задачи

### 3.1.1. Создать DI Types

```typescript
// src/composition-root/types.ts
export const TYPES = {
  // Config
  ServerConfig: Symbol.for('ServerConfig'),

  // Infrastructure
  Logger: Symbol.for('Logger'),
  HttpClient: Symbol.for('HttpClient'),
  OAuthClient: Symbol.for('OAuthClient'),
  CacheManager: Symbol.for('CacheManager'),

  // Operations
  GetProjectsOperation: Symbol.for('GetProjectsOperation'),
  GetProjectOperation: Symbol.for('GetProjectOperation'),
  GetProjectDataOperation: Symbol.for('GetProjectDataOperation'),
  CreateProjectOperation: Symbol.for('CreateProjectOperation'),
  UpdateProjectOperation: Symbol.for('UpdateProjectOperation'),
  DeleteProjectOperation: Symbol.for('DeleteProjectOperation'),

  GetTaskOperation: Symbol.for('GetTaskOperation'),
  GetTasksOperation: Symbol.for('GetTasksOperation'),
  CreateTaskOperation: Symbol.for('CreateTaskOperation'),
  BatchCreateTasksOperation: Symbol.for('BatchCreateTasksOperation'),
  UpdateTaskOperation: Symbol.for('UpdateTaskOperation'),
  CompleteTaskOperation: Symbol.for('CompleteTaskOperation'),
  DeleteTaskOperation: Symbol.for('DeleteTaskOperation'),

  // Facade
  TickTickFacade: Symbol.for('TickTickFacade'),

  // MCP
  ToolRegistry: Symbol.for('ToolRegistry'),
  SearchEngine: Symbol.for('SearchEngine'),
} as const;
```

### 3.1.2. Создать TickTickFacade

```typescript
// src/ticktick_api/facade/ticktick.facade.ts
import { injectable, inject } from 'inversify';
import { TYPES } from '#composition-root/types.js';
import type { ProjectWithUnknownFields } from '#ticktick_api/entities/project.entity.js';
import type { TaskWithUnknownFields } from '#ticktick_api/entities/task.entity.js';
import type { BatchResult } from '@mcp-framework/infrastructure';

// Import all operation types
import type { GetProjectsOperation } from '#ticktick_api/api_operations/projects/get-projects.operation.js';
// ... и остальные

@injectable()
export class TickTickFacade {
  constructor(
    @inject(TYPES.GetProjectsOperation) private readonly getProjectsOp: GetProjectsOperation,
    @inject(TYPES.GetProjectOperation) private readonly getProjectOp: GetProjectOperation,
    @inject(TYPES.GetProjectDataOperation) private readonly getProjectDataOp: GetProjectDataOperation,
    @inject(TYPES.CreateProjectOperation) private readonly createProjectOp: CreateProjectOperation,
    @inject(TYPES.UpdateProjectOperation) private readonly updateProjectOp: UpdateProjectOperation,
    @inject(TYPES.DeleteProjectOperation) private readonly deleteProjectOp: DeleteProjectOperation,

    @inject(TYPES.GetTaskOperation) private readonly getTaskOp: GetTaskOperation,
    @inject(TYPES.GetTasksOperation) private readonly getTasksOp: GetTasksOperation,
    @inject(TYPES.CreateTaskOperation) private readonly createTaskOp: CreateTaskOperation,
    @inject(TYPES.BatchCreateTasksOperation) private readonly batchCreateTasksOp: BatchCreateTasksOperation,
    @inject(TYPES.UpdateTaskOperation) private readonly updateTaskOp: UpdateTaskOperation,
    @inject(TYPES.CompleteTaskOperation) private readonly completeTaskOp: CompleteTaskOperation,
    @inject(TYPES.DeleteTaskOperation) private readonly deleteTaskOp: DeleteTaskOperation,
  ) {}

  // ========== Projects ==========

  async getProjects(): Promise<ProjectWithUnknownFields[]> {
    return this.getProjectsOp.execute();
  }

  async getProject(projectId: string): Promise<ProjectWithUnknownFields> {
    return this.getProjectOp.execute(projectId);
  }

  async getProjectData(projectId: string): Promise<ProjectData> {
    return this.getProjectDataOp.execute(projectId);
  }

  async createProject(dto: CreateProjectDto): Promise<ProjectWithUnknownFields> {
    return this.createProjectOp.execute(dto);
  }

  async updateProject(projectId: string, dto: UpdateProjectDto): Promise<ProjectWithUnknownFields> {
    return this.updateProjectOp.execute(projectId, dto);
  }

  async deleteProject(projectId: string): Promise<void> {
    return this.deleteProjectOp.execute(projectId);
  }

  // ========== Tasks ==========

  async getTask(projectId: string, taskId: string): Promise<TaskWithUnknownFields> {
    return this.getTaskOp.execute(projectId, taskId);
  }

  async getTasks(refs: TaskRef[]): Promise<BatchResult<string, TaskWithUnknownFields>> {
    return this.getTasksOp.execute(refs);
  }

  async createTask(dto: CreateTaskDto): Promise<TaskWithUnknownFields> {
    return this.createTaskOp.execute(dto);
  }

  async batchCreateTasks(dtos: CreateTaskDto[]): Promise<BatchResult<number, TaskWithUnknownFields>> {
    return this.batchCreateTasksOp.execute(dtos);
  }

  async updateTask(projectId: string, taskId: string, dto: UpdateTaskDto): Promise<TaskWithUnknownFields> {
    return this.updateTaskOp.execute(projectId, taskId, dto);
  }

  async completeTask(projectId: string, taskId: string): Promise<void> {
    return this.completeTaskOp.execute(projectId, taskId);
  }

  async deleteTask(projectId: string, taskId: string): Promise<void> {
    return this.deleteTaskOp.execute(projectId, taskId);
  }

  // ========== Convenience Methods ==========

  async getAllTasks(): Promise<TaskWithUnknownFields[]> {
    const projects = await this.getProjects();
    const allTasks: TaskWithUnknownFields[] = [];

    for (const project of projects) {
      const data = await this.getProjectData(project.id);
      allTasks.push(...data.tasks);
    }

    return allTasks;
  }

  async searchTasks(query: string): Promise<TaskWithUnknownFields[]> {
    const allTasks = await this.getAllTasks();
    const lowerQuery = query.toLowerCase();

    return allTasks.filter(task =>
      task.title.toLowerCase().includes(lowerQuery) ||
      task.content?.toLowerCase().includes(lowerQuery)
    );
  }

  async getTasksByPriority(priority: number): Promise<TaskWithUnknownFields[]> {
    const allTasks = await this.getAllTasks();
    return allTasks.filter(task => task.priority === priority);
  }

  async getTasksDueInRange(startDate: Date, endDate: Date): Promise<TaskWithUnknownFields[]> {
    const allTasks = await this.getAllTasks();
    return allTasks.filter(task => {
      if (!task.dueDate) return false;
      const due = new Date(task.dueDate);
      return due >= startDate && due <= endDate;
    });
  }

  async getOverdueTasks(): Promise<TaskWithUnknownFields[]> {
    const allTasks = await this.getAllTasks();
    const now = new Date();
    return allTasks.filter(task => {
      if (!task.dueDate || task.status === 2) return false;
      return new Date(task.dueDate) < now;
    });
  }
}
```

### 3.1.3. Создать operation-definitions.ts

```typescript
// src/composition-root/definitions/operation-definitions.ts
import { GetProjectsOperation } from '#ticktick_api/api_operations/projects/get-projects.operation.js';
import { GetProjectOperation } from '#ticktick_api/api_operations/projects/get-project.operation.js';
import { GetProjectDataOperation } from '#ticktick_api/api_operations/projects/get-project-data.operation.js';
import { CreateProjectOperation } from '#ticktick_api/api_operations/projects/create-project.operation.js';
import { UpdateProjectOperation } from '#ticktick_api/api_operations/projects/update-project.operation.js';
import { DeleteProjectOperation } from '#ticktick_api/api_operations/projects/delete-project.operation.js';

import { GetTaskOperation } from '#ticktick_api/api_operations/tasks/get-task.operation.js';
import { GetTasksOperation } from '#ticktick_api/api_operations/tasks/get-tasks.operation.js';
import { CreateTaskOperation } from '#ticktick_api/api_operations/tasks/create-task.operation.js';
import { BatchCreateTasksOperation } from '#ticktick_api/api_operations/tasks/batch-create-tasks.operation.js';
import { UpdateTaskOperation } from '#ticktick_api/api_operations/tasks/update-task.operation.js';
import { CompleteTaskOperation } from '#ticktick_api/api_operations/tasks/complete-task.operation.js';
import { DeleteTaskOperation } from '#ticktick_api/api_operations/tasks/delete-task.operation.js';

export const OPERATION_CLASSES = [
  // Projects
  GetProjectsOperation,
  GetProjectOperation,
  GetProjectDataOperation,
  CreateProjectOperation,
  UpdateProjectOperation,
  DeleteProjectOperation,

  // Tasks
  GetTaskOperation,
  GetTasksOperation,
  CreateTaskOperation,
  BatchCreateTasksOperation,
  UpdateTaskOperation,
  CompleteTaskOperation,
  DeleteTaskOperation,
] as const;
```

### 3.1.4. Создать container.ts

```typescript
// src/composition-root/container.ts
import 'reflect-metadata';
import { Container } from 'inversify';
import { TYPES } from './types.js';
import { OPERATION_CLASSES } from './definitions/operation-definitions.js';
import { TOOL_CLASSES } from './definitions/tool-definitions.js';

import type { ServerConfig } from '#config/server-config.interface.js';
import { loadConfig } from '#config/config-loader.js';

import { TickTickFacade } from '#ticktick_api/facade/ticktick.facade.js';
import { TickTickOAuthClient } from '#ticktick_api/auth/oauth-client.js';
import { AuthenticatedHttpClient } from '#ticktick_api/http/authenticated-http-client.js';

import {
  HttpClientFactory,
  InMemoryCacheManager,
  createLogger
} from '@mcp-framework/infrastructure';
import { ToolRegistry } from '@mcp-framework/core';

export function createContainer(): Container {
  const container = new Container({ defaultScope: 'Singleton' });
  const config = loadConfig();

  // Bind config
  container.bind(TYPES.ServerConfig).toConstantValue(config);

  // Bind infrastructure
  bindInfrastructure(container, config);

  // Bind operations
  bindOperations(container);

  // Bind facade
  container.bind(TYPES.TickTickFacade).to(TickTickFacade);

  // Bind tools
  bindTools(container);

  // Bind MCP components
  bindMCP(container, config);

  return container;
}

function bindInfrastructure(container: Container, config: ServerConfig): void {
  // Logger
  const logger = createLogger({ name: 'ticktick-mcp' });
  container.bind(TYPES.Logger).toConstantValue(logger);

  // Base HTTP client with retry
  const baseHttpClient = HttpClientFactory.create({
    retryAttempts: config.retry.attempts,
    retryMinDelay: config.retry.minDelay,
    retryMaxDelay: config.retry.maxDelay,
  });

  // OAuth client
  const oauthClient = new TickTickOAuthClient(config.oauth, baseHttpClient);
  container.bind(TYPES.OAuthClient).toConstantValue(oauthClient);

  // Authenticated HTTP client
  const authHttpClient = new AuthenticatedHttpClient(
    baseHttpClient,
    oauthClient,
    config.api.baseUrl
  );
  container.bind(TYPES.HttpClient).toConstantValue(authHttpClient);

  // Cache manager
  const cacheManager = new InMemoryCacheManager(config.cache.ttlMs);
  container.bind(TYPES.CacheManager).toConstantValue(cacheManager);
}

function bindOperations(container: Container): void {
  for (const OperationClass of OPERATION_CLASSES) {
    const symbol = Symbol.for(OperationClass.name);
    container.bind(symbol).toDynamicValue((context) => {
      const httpClient = context.container.get(TYPES.HttpClient);
      const cacheManager = context.container.get(TYPES.CacheManager);
      const logger = context.container.get(TYPES.Logger);
      const config = context.container.get(TYPES.ServerConfig);
      return new OperationClass(httpClient, cacheManager, logger, config);
    });
  }
}

function bindTools(container: Container): void {
  for (const ToolClass of TOOL_CLASSES) {
    const symbol = Symbol.for(ToolClass.name);
    container.bind(symbol).toDynamicValue((context) => {
      const facade = context.container.get<TickTickFacade>(TYPES.TickTickFacade);
      const logger = context.container.get(TYPES.Logger);
      return new ToolClass(facade, logger);
    });
  }
}

function bindMCP(container: Container, config: ServerConfig): void {
  container.bind(TYPES.ToolRegistry).toDynamicValue((context) => {
    const tools = TOOL_CLASSES.map(ToolClass =>
      context.container.get(Symbol.for(ToolClass.name))
    );
    return new ToolRegistry(tools, config.tools);
  });
}
```

---

## Валидация

```bash
npm run typecheck
npm run lint
```

---

## Чек-лист завершения

- [ ] types.ts содержит все Symbol токены
- [ ] TickTickFacade делегирует все операции
- [ ] Convenience методы (getAllTasks, searchTasks, etc.) работают
- [ ] operation-definitions.ts экспортирует все операции
- [ ] container.ts создаёт DI контейнер
- [ ] Все bindings корректны
- [ ] `npm run typecheck` проходит
