# Core Package Analysis

**Date:** 2025-11-21
**Package:** `@mcp-framework/core`
**Path:** `packages/framework/core/`

---

## ğŸ“Š Metrics

| Metric | Value | Status |
|--------|-------|--------|
| Total LoC | 2380 | âœ… |
| Total files | 21 | âœ… |
| Average LoC per file | 113.3 | âœ… Good |
| Max file size | 549 lines (tool-registry.ts) | âš ï¸ **EXCEEDS LIMIT** |
| Average imports per file | 1.33 | âœ… Excellent coupling |
| `any` usage | 1 legitimate (ToolConstructor) | âœ… Good |
| Files >400 lines | 1 (tool-registry.ts) | âš ï¸ |

---

## âœ… Strong Points

### 1. **Excellent BaseTool Architecture**

**Template Method Pattern:**
```typescript
abstract class BaseTool<TFacade> {
  // Template method
  getDefinition(): ToolDefinition {
    const schema = this.getParamsSchema?.();
    if (schema) {
      return generateDefinitionFromSchema(schema, metadata);
    }
    return this.buildDefinition(); // legacy
  }

  // Hook methods
  protected getParamsSchema?(): z.ZodObject<z.ZodRawShape>;
  protected buildDefinition(): ToolDefinition;
  abstract execute(params: ToolCallParams): Promise<ToolResult>;
}
```

**Why this is excellent:**
- âœ… **DRY Principle:** Schema is single source of truth
- âœ… **OCP:** Easy to add new tools without modifying base class
- âœ… **SRP:** Clear separation - validation, execution, formatting
- âœ… **Backward compatibility:** Supports both auto-generation and manual definition
- âœ… **Type-safe:** Strong generics for TFacade

**Validation through Zod:**
- âœ… Consistent validation pattern
- âœ… Type inference from schema
- âœ… Clear error messages

**Error handling:**
- âœ… Preserves ApiErrorClass details (statusCode, retryAfter, errors)
- âœ… Proper logging
- âœ… MCP-compliant result format

---

### 2. **Schema-to-Definition Generator**

**File:** `definition/schema-to-definition.ts` (189 lines)

**Why this is excellent:**
- âœ… **Eliminates schema â†” definition drift** (critical for MCP tools)
- âœ… **Extensible:** Custom transforms and field descriptions
- âœ… **Type-safe:** Leverages Zod type inference
- âœ… **Well-documented:** Clear examples

```typescript
// No need to maintain separate definition - auto-generated!
protected getParamsSchema() {
  return z.object({
    issueKey: z.string().min(1).describe('Issue key'),
    fields: z.array(z.string()).optional()
  });
}
// â†’ inputSchema generated automatically
```

**Trade-off analysis:**
- âœ… Pro: DRY, no schema/definition mismatch
- âœ… Pro: Less code to maintain
- âš ï¸ Con: Slight learning curve for developers

---

### 3. **Utilities - Clean Separation of Concerns**

**BatchResultProcessor (`utils/batch-result-processor.ts` - 115 lines):**
- âœ… SRP: Only transforms BatchResult â†’ ProcessedBatchResult
- âœ… Type-safe with generics
- âœ… Preserves ApiErrorClass details
- âœ… Optional filtering support

**ResponseFieldFilter (`utils/response-field-filter.ts` - 185 lines):**
- âœ… SRP: Only filters response fields
- âœ… Dot notation support
- âœ… Type-safe

**ResultLogger (`utils/result-logger.ts` - 87 lines):**
- âœ… SRP: Only formats and logs results
- âœ… Clean interface

---

### 4. **Low Coupling & High Cohesion**
- Average 1.33 imports/file (excellent!)
- Clear module boundaries
- Each component focused on single responsibility

---

## ğŸ”´ Critical Problems

### Problem #1: ToolRegistry Exceeds File Size Limit

**Priority:** ğŸŸ¡ IMPORTANT
**SOLID Violation:** SRP
**File:** `tool-registry.ts` (549 lines, limit is 400)

**Why this is a problem:**
The ToolRegistry has grown to handle too many responsibilities:

1. **Tool registration** (âœ… core responsibility)
2. **Lazy initialization** (âœ… core responsibility)
3. **Priority-based sorting** (âš ï¸ could be extracted)
4. **Category filtering** (âš ï¸ should be extracted)
5. **Essential tools filtering** (âš ï¸ should be extracted)
6. **Disabled groups filtering** (âš ï¸ should be extracted)
7. **Discovery mode logic** (âš ï¸ should be extracted)
8. **Category validation** (âš ï¸ should be extracted)

**Specific violations:**
- `getDefinitionsByCategories()`: ~140 lines (category filtering + validation)
- `applyDisabledFilter()`: ~30 lines (negative filtering)
- `sortByPriority()`: ~75 lines (sorting + logging)
- `getDefinitionsByMode()`: ~60 lines (mode logic)

**Evidence:**
```typescript
// Current: All in ToolRegistry
class ToolRegistry {
  getDefinitionsByCategories(filter: ParsedCategoryFilter) { /* 140 lines */ }
  private applyDisabledFilter(tools: BaseTool[], filter: ParsedCategoryFilter) { /* 30 lines */ }
  private sortByPriority(tools: BaseTool[]) { /* 75 lines */ }
  getDefinitionsByMode(...) { /* 60 lines */ }
}
```

**Recommended refactoring:**
```typescript
// Extract filtering logic to separate class
class ToolFilterService {
  filterByCategories(tools: BaseTool[], filter: ParsedCategoryFilter): BaseTool[];
  applyDisabledFilter(tools: BaseTool[], filter: ParsedCategoryFilter): BaseTool[];
  validateCategories(filter: ParsedCategoryFilter, knownCategories: Set<string>): void;
}

class ToolSorter {
  sortByPriority(tools: BaseTool[]): BaseTool[];
}

// Slim ToolRegistry
class ToolRegistry {
  private filterService: ToolFilterService;
  private sorter: ToolSorter;

  getDefinitions(): ToolDefinition[] {
    const tools = Array.from(this.tools.values());
    return this.sorter.sortByPriority(tools).map(t => t.getDefinition());
  }

  getDefinitionsByCategories(filter: ParsedCategoryFilter): ToolDefinition[] {
    const tools = Array.from(this.tools.values());
    const filtered = this.filterService.filterByCategories(tools, filter);
    return this.sorter.sortByPriority(filtered).map(t => t.getDefinition());
  }
}
```

**Benefits:**
- âœ… SRP: Each class has one responsibility
- âœ… Testability: Easy to test filtering/sorting independently
- âœ… Reusability: FilterService can be used elsewhere
- âœ… File size: ToolRegistry < 250 lines, ToolFilterService ~200 lines

**Effort:** MEDIUM (4-6 hours)
- Extract ToolFilterService (~2-3h)
- Extract ToolSorter (~1h)
- Update tests (~1-2h)

---

## âš ï¸ Important Issues

### Problem #2: ToolConstructor Uses `any`

**Priority:** ğŸŸ¢ NICE TO HAVE
**SOLID Violation:** None (pragmatic decision)
**File:** `tool-registry.ts:28`

**Current:**
```typescript
export interface ToolConstructor {
  new (...args: any[]): BaseTool<any>; // eslint-disable-line
  name: string;
}
```

**Why this is not critical:**
- DI container handles actual instantiation
- Only used for type checking
- Has eslint-disable comment (acknowledged)

**Potential improvement (if needed):**
```typescript
export interface ToolConstructor<TFacade = unknown> {
  new (facade: TFacade, logger: Logger): BaseTool<TFacade>;
  readonly METADATA: StaticToolMetadata;
  name: string;
}
```

**Trade-off:**
- âœ… Pro: Stronger typing
- âš ï¸ Con: More complex, may not be worth it given DI usage

---

## ğŸŸ¢ Nice to Have

### Improvement #1: Add ToolDefinitionBuilder

**Priority:** ğŸŸ¢ NICE TO HAVE
**Effort:** LOW

**Motivation:**
Fluent API for manual definition building (legacy mode)

**Example:**
```typescript
class ToolDefinitionBuilder {
  private definition: Partial<ToolDefinition> = {};

  withName(name: string): this;
  withDescription(desc: string): this;
  withProperty(name: string, schema: Record<string, unknown>): this;
  withRequired(fields: string[]): this;
  build(): ToolDefinition;
}

// Usage
protected buildDefinition(): ToolDefinition {
  return new ToolDefinitionBuilder()
    .withName('my_tool')
    .withDescription('Does something')
    .withProperty('param1', { type: 'string' })
    .withRequired(['param1'])
    .build();
}
```

**Benefits:**
- âœ… Better DX for legacy tools
- âœ… Validation at build time
- âœ… Consistent definition structure

---

## ğŸ“‹ SOLID Compliance

| Principle | Status | Comment |
|-----------|--------|---------|
| **SRP** | âš ï¸ | **Violated by ToolRegistry** (too many responsibilities), other components âœ… |
| **OCP** | âœ… | BaseTool easily extensible, auto-registration from DI |
| **LSP** | âœ… | No inheritance issues |
| **ISP** | âœ… | Interfaces are focused |
| **DIP** | âœ… | Depends on abstractions (Logger from infrastructure, DI container) |

---

## ğŸ’¡ Key Takeaways

### Strengths
1. **ğŸ† Excellent BaseTool design** - Template Method + auto-generation from schema
2. **ğŸ† Schema-to-Definition Generator** - Eliminates drift, DRY principle
3. **ğŸ† Strong type safety** - Proper use of generics and Zod
4. **ğŸ† Low coupling** (1.33 imports/file)

### Issues
1. **ğŸŸ¡ ToolRegistry too large** (549 lines) - Extract filtering/sorting logic
2. **ğŸŸ¢ Minor: `any` in ToolConstructor** - Not critical, but could be improved

### Priority Actions
1. **Extract ToolFilterService and ToolSorter** from ToolRegistry
2. **(Optional) Add ToolDefinitionBuilder** for better DX

---

## ğŸ“ˆ Reusability Assessment

**Current State:** âœ… **HIGHLY REUSABLE**

**Why:**
- âœ… Zero domain coupling (only depends on infrastructure)
- âœ… Generic BaseTool<TFacade> works with any API
- âœ… Schema-to-definition is MCP-agnostic
- âœ… Utilities are domain-independent

**Can be used for:**
- Any MCP server (GitHub, Jira, Slack, etc.)
- Any tool framework requiring schema validation
- Any system needing batch result processing

---

## ğŸ”— Related Files

- [Infrastructure Package Analysis](./2.1_infrastructure_analysis.md)
- [Search Package Analysis](./2.1_search_analysis.md)
- [Cross-Package Patterns](./2.1_cross_package_patterns.md)
