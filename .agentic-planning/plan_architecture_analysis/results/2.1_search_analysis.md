# Search Package Analysis

**Date:** 2025-11-21
**Package:** `@mcp-framework/search`
**Path:** `packages/framework/search/`

---

## ğŸ“Š Metrics

| Metric | Value | Status |
|--------|-------|--------|
| Total LoC | 1837 | âœ… |
| Total files | 20 | âœ… |
| Average LoC per file | 91.85 | âœ… Excellent |
| Max file size | 276 lines | âœ… Well below limit |
| Files >400 lines | 0 | âœ… |
| `any` usage | 0 | âœ… Excellent |

---

## âœ… Strong Points

### 1. **Excellent Architecture - Strategy Pattern**

**File:** `strategies/search-strategy.interface.ts` (30 lines)

```typescript
export interface ISearchStrategy {
  search(query: string, tools: StaticToolIndex[]): SearchResult[];
}
```

**Why this is excellent:**
- âœ… **OCP:** Easy to add new search algorithms without modifying existing code
- âœ… **SRP:** Each strategy handles one search algorithm
- âœ… **Testability:** Easy to test strategies independently
- âœ… **Flexibility:** Can combine strategies (WeightedCombinedStrategy)

**Available strategies:**
- `NameSearchStrategy` - Exact/partial name match
- `DescriptionSearchStrategy` - Full-text search in descriptions
- `CategorySearchStrategy` - Category-based filtering
- `FuzzySearchStrategy` - Fuzzy matching (typos, partial matches)
- `WeightedCombinedStrategy` - Combines multiple strategies with weights

---

### 2. **ToolSearchEngine - Well-Designed Core**

**File:** `engine/tool-search-engine.ts` (276 lines)

**Responsibilities (SRP compliant):**
- âœ… Search execution through strategies
- âœ… Category/type filtering
- âœ… Result caching (LRU)
- âœ… Result formatting by detail level
- âœ… Lazy loading of full metadata

**Key features:**

**Dual Index Support:**
```typescript
constructor(
  private readonly staticIndex: readonly StaticToolIndex[] | null,
  private readonly toolRegistry: ToolRegistry,
  searchStrategy: ISearchStrategy
) {
  // Supports both static (compile-time) and dynamic (runtime) index
}
```

**Lazy Loading:**
- Index built on first search (if no static index provided)
- Full metadata loaded only for `detailLevel='full'`
- Efficient memory usage

**Caching:**
- Simple LRU cache (max 100 entries)
- Cache key based on query params
- Prevents redundant searches

**Detail Levels:**
- `name_only` - Just tool name (minimal data)
- `name_and_description` - Name + short description + category + score
- `full` - Everything including inputSchema, examples, matchDetails

---

### 3. **Hybrid Approach: Static + Dynamic Index**

**Why this is smart:**

**Compile-time index (`generated-index.ts`):**
- âœ… Fast startup (pre-computed tokens)
- âœ… No runtime cost for indexing
- âœ… Useful for production

**Runtime index (`buildIndexFromRegistry()`):**
- âœ… Always up-to-date with tools
- âœ… No need to regenerate after adding tools
- âœ… Useful for development/testing

**ToolSearchEngine supports both:**
```typescript
// Option 1: Static index (compile-time)
const engine = new ToolSearchEngine(TOOL_SEARCH_INDEX, registry, strategy);

// Option 2: Dynamic index (runtime)
const engine = new ToolSearchEngine(null, registry, strategy);
// Index built lazily from registry
```

---

### 4. **Clean Integration with Core**

**File:** `tools/search-tools.tool.ts`

- âœ… Extends `BaseTool<ToolSearchEngine>` - Proper use of framework
- âœ… Uses schema-to-definition auto-generation
- âœ… Follows all framework conventions
- âœ… DI-compatible (registered via Symbol)

---

### 5. **Small, Focused Files**

- Max file size: 276 lines (ToolSearchEngine)
- Average: 91.85 lines
- Each file has clear single responsibility

---

## âš ï¸ Important Issues

### Problem #1: Generated Index Contains Domain-Specific Tools

**Priority:** ğŸŸ¡ IMPORTANT
**SOLID Violation:** SRP
**File:** `generated-index.ts` (146 lines)

**Current state:**
```typescript
export const TOOL_SEARCH_INDEX: readonly StaticToolIndex[] = [
  {
    name: 'fr_yandex_tracker_ping',
    category: ToolCategory.ISSUES,
    // ... Yandex Tracker specific
  },
  {
    name: 'fr_yandex_tracker_get_issues',
    // ... Yandex Tracker specific
  },
  // ... all Yandex Tracker tools
];
```

**Why this is a problem:**
- Framework package contains domain-specific data
- Not reusable for other projects
- Breaks "zero domain coupling" rule for framework

**Recommended solution:**
```
Option 1: Move to yandex-tracker package
- Move generated-index.ts â†’ packages/servers/yandex-tracker/src/tools/
- Keep buildIndexFromRegistry() in search package (generic)
- Yandex-tracker provides its own static index

Option 2: Make it truly optional
- Keep TOOL_SEARCH_INDEX as empty array in framework
- Document that projects should generate their own index
- Provide script in yandex-tracker for generation
```

**Effort:** LOW (1-2 hours)
- Move file
- Update imports
- Update generation script

---

### Problem #2: Code Duplication - tokenize() and getShortDescription()

**Priority:** ğŸŸ¢ NICE TO HAVE
**SOLID Violation:** DRY
**Files:**
- `engine/tool-search-engine.ts:95-110`
- `utils/build-index-from-registry.ts:26-40`

**Current state:**
```typescript
// Duplicated in 2 files
private tokenize(text: string): string[] {
  return text.toLowerCase().replace(/[_-]/g, ' ').split(/\W+/).filter(token => token.length > 0);
}

private getShortDescription(description: string): string {
  const firstSentence = description.split(/[.!?]/)[0];
  return firstSentence ? firstSentence.trim() : description;
}
```

**Why this is a problem:**
- Same logic in 2 places
- Changes need to be applied twice
- Inconsistency risk

**Recommended solution:**
```typescript
// Create utils/text-utils.ts
export function tokenize(text: string): string[] {
  return text
    .toLowerCase()
    .replace(/[_-]/g, ' ')
    .split(/\W+/)
    .filter(token => token.length > 0);
}

export function getShortDescription(description: string): string {
  const firstSentence = description.split(/[.!?]/)[0];
  return firstSentence ? firstSentence.trim() : description;
}

// Use in both files
import { tokenize, getShortDescription } from '../utils/text-utils.js';
```

**Effort:** LOW (30 minutes)

---

## ğŸŸ¢ Nice to Have

### Improvement #1: Better LRU Cache Implementation

**Priority:** ğŸŸ¢ NICE TO HAVE
**Effort:** LOW

**Current:**
```typescript
// Simple FIFO, not true LRU
if (this.cache.size > this.MAX_CACHE_SIZE) {
  const firstKey = this.cache.keys().next().value;
  this.cache.delete(firstKey);
}
```

**Issue:**
- Deletes oldest inserted, not least recently used
- Frequently accessed items may be evicted

**Better solution:**
```typescript
import { LRUCache } from 'lru-cache'; // npm package

// Or implement proper LRU:
class LRUCache<K, V> {
  private cache: Map<K, V>;
  private readonly maxSize: number;

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      // Move to end (most recently used)
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    }
    this.cache.set(key, value);

    if (this.cache.size > this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
  }
}
```

**Trade-off:**
- âœ… Pro: Better hit rate for frequent queries
- âš ï¸ Con: Slightly more complex
- âš ï¸ Con: Adding dependency (if using lru-cache package)

---

### Improvement #2: Search Strategy Metrics

**Priority:** ğŸŸ¢ NICE TO HAVE
**Effort:** MEDIUM

**Motivation:**
Track which strategies work best for optimization

**Example:**
```typescript
interface SearchMetrics {
  strategyName: string;
  totalSearches: number;
  avgResultCount: number;
  avgScore: number;
  cacheHitRate: number;
}

class ToolSearchEngine {
  private metrics: Map<string, SearchMetrics>;

  search(params: SearchParams): SearchResponse {
    const startTime = Date.now();
    // ... search logic
    this.trackMetrics(strategy, results, Date.now() - startTime);
  }

  getMetrics(): SearchMetrics[] {
    return Array.from(this.metrics.values());
  }
}
```

**Benefits:**
- âœ… Data-driven optimization
- âœ… Can adjust strategy weights based on real usage
- âœ… Helps identify inefficient queries

---

## ğŸ“‹ SOLID Compliance

| Principle | Status | Comment |
|-----------|--------|---------|
| **SRP** | âš ï¸ | **Violated by generated-index.ts** (contains domain data), other components âœ… |
| **OCP** | âœ… | Easy to add new search strategies via interface |
| **LSP** | âœ… | No inheritance issues |
| **ISP** | âœ… | ISearchStrategy is minimal and focused |
| **DIP** | âœ… | Depends on abstractions (ISearchStrategy, ToolRegistry) |

---

## ğŸ’¡ Key Takeaways

### Strengths
1. **ğŸ† Excellent Strategy Pattern** - Easy to add/swap search algorithms
2. **ğŸ† Dual index support** - Flexibility for both compile-time and runtime
3. **ğŸ† Lazy loading** - Efficient memory usage
4. **ğŸ† Small, focused files** - All < 300 lines
5. **ğŸ† Clean integration with Core** - Follows all framework patterns

### Issues
1. **ğŸŸ¡ generated-index.ts has domain coupling** - Move to yandex-tracker
2. **ğŸŸ¢ Code duplication** - Extract text utils
3. **ğŸŸ¢ Simple cache** - Could use proper LRU

### Priority Actions
1. **Move generated-index.ts to yandex-tracker** (breaks domain coupling)
2. **(Optional) Extract text utils** (DRY principle)
3. **(Optional) Improve LRU cache** (better performance)

---

## ğŸ“ˆ Reusability Assessment

**Current State:** âš ï¸ **MOSTLY REUSABLE** (with one fix)

**Blockers:**
- âŒ generated-index.ts contains Yandex Tracker specific tools

**After fixing:**
- âœ… Strategy Pattern works for any tool system
- âœ… ToolSearchEngine is domain-agnostic
- âœ… buildIndexFromRegistry() works with any ToolRegistry

**Can be used for:**
- Any MCP server (GitHub, Jira, Slack, etc.)
- Any system with searchable tools/commands
- Any CLI with discoverability features

---

## ğŸ”— Related Files

- [Infrastructure Package Analysis](./2.1_infrastructure_analysis.md)
- [Core Package Analysis](./2.1_core_analysis.md)
- [Cross-Package Patterns](./2.1_cross_package_patterns.md)
