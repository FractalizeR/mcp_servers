# Code Quality - Execution Plan

**–î–∞—Ç–∞:** 2025-11-21
**Scope:** –ü–æ—à–∞–≥–æ–≤—ã–π –ø–ª–∞–Ω —Ä–µ—à–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º code quality

---

## Dependency Analysis

### –ù–µ–∑–∞–≤–∏—Å–∏–º—ã–µ —É–ª—É—á—à–µ–Ω–∏—è (Phase 1)

**–ú–æ–∂–Ω–æ –Ω–∞—á–∏–Ω–∞—Ç—å –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ, –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ —Å 2.1/2.2:**

‚úÖ CLI BaseConnector creation
‚úÖ Type safety improvements
‚úÖ Function extraction (logger, setupServer)
‚úÖ Schema optimizations
‚úÖ Minor fixes

### –ó–∞–≤–∏—Å–∏–º—ã–µ —É–ª—É—á—à–µ–Ω–∏—è (Phase 2)

**–ñ–¥—É—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞:**

‚è∏Ô∏è tool-registry.ts refactoring
- –ó–∞–≤–∏—Å–∏—Ç –æ—Ç –æ–±—â–µ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ Framework packages (2.1)
- –¢—Ä–µ–±—É–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏–∏ —Å –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–º–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è–º–∏

---

## Phase 1: Quick Wins (–ù–µ–∑–∞–≤–∏—Å–∏–º—ã–µ)

**Timeline:** 8-12 hours
**Can start:** Immediately (parallel with 2.1/2.2)
**Risk:** LOW

---

### 1.1: Create BaseConnector for CLI

**Priority:** üî¥ CRITICAL
**Effort:** 4-6 hours
**Impact:** HIGH
**ROI:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Problem:**
- 12 code clones in CLI connectors
- ~200+ lines of duplication
- Hard to maintain and extend

**Solution:**

**Step 1:** Create base class (2h)
```typescript
// packages/servers/yandex-tracker/src/cli/connectors/base/base-connector.ts

export abstract class BaseConnector {
  // Abstract methods - must implement
  abstract getConfigPath(): string;
  abstract getDefaultConfig(): unknown;
  abstract validate(config: unknown): boolean;

  // Common methods - shared implementation
  async readConfig(): Promise<unknown> { }
  async writeConfig(config: unknown): Promise<void> { }
  async testConnection(): Promise<boolean> { }
  formatOutput(config: unknown): string { }
  handleError(error: Error): void { }
}
```

**Step 2:** Refactor existing connectors (2-3h)
- gemini.connector.ts
- qwen.connector.ts
- claude-desktop.connector.ts
- claude-code.connector.ts
- codex.connector.ts

**Step 3:** Tests and validation (1h)
- Unit tests for BaseConnector
- Integration tests for all connectors
- Smoke test CLI commands

**Expected Result:**
- Reduced from ~750 lines to ~350 lines total
- Single source of truth for common logic
- Easier to add new connectors

---

### 1.2: Type Safety Improvements

**Priority:** üü° IMPORTANT
**Effort:** 2-3 hours
**Impact:** MEDIUM
**ROI:** ‚≠ê‚≠ê‚≠ê‚≠ê

**Problem 1:** ApiError casts without type guard (10 places)

**Solution:**
```typescript
// packages/framework/infrastructure/src/http/error/api-error.class.ts

export function isApiError(error: unknown): error is ApiError {
  return error instanceof ApiError;
}

// Usage
catch (error: unknown) {
  if (isApiError(error)) {
    // Safe access to error.statusCode, error.retryAfter, etc.
  }
}
```

**Affected files:**
- infrastructure/src/http/retry/retry-handler.ts
- +9 other files

**Effort:** 1 hour

---

**Problem 2:** Double casting (5 places)

**Solution:**
```typescript
// Before
const metadata = (ToolClass as unknown as ToolWithMetadata).METADATA;

// After - with type guard
function hasMetadata(obj: unknown): obj is ToolWithMetadata {
  return typeof obj === 'object' && obj !== null && 'METADATA' in obj;
}

if (hasMetadata(ToolClass)) {
  const metadata = ToolClass.METADATA;
}
```

**Affected files:**
- search/scripts/generate-tool-index.ts
- +4 other files

**Effort:** 1-2 hours

---

### 1.3: Extract Methods in createPinoLogger

**Priority:** üü° IMPORTANT
**Effort:** 2-3 hours
**Impact:** MEDIUM
**ROI:** ‚≠ê‚≠ê‚≠ê‚≠ê

**Problem:**
- 137 lines, complexity 18
- Mixes multiple responsibilities

**Solution:**

**Step 1:** Extract transport creators (1.5h)
```typescript
private createConsoleTransport(config: LoggerConfig): Transport {
  return pino.transport({
    target: 'pino-pretty',
    options: { /* ... */ }
  });
}

private createFileTransport(config: LoggerConfig): Transport {
  // File rotation logic
}

private createStreamTransport(config: LoggerConfig): Transport {
  // Stream configuration
}
```

**Step 2:** Simplify main method (0.5h)
```typescript
private createPinoLogger(config: LoggerConfig): PinoLogger {
  const baseOptions = this.createBaseOptions(config);
  const transports = this.selectTransports(config);
  return pino(baseOptions, transports);
}
```

**Step 3:** Tests (1h)
- Test each transport creator
- Integration tests

**Expected Result:**
- Reduced from 137 to ~40-50 lines
- Complexity from 18 to ~8
- Better testability

---

### 1.4: Refactor setupServer

**Priority:** üü° IMPORTANT
**Effort:** 2-3 hours
**Impact:** MEDIUM
**ROI:** ‚≠ê‚≠ê‚≠ê

**Problem:**
- 214 lines
- Too many responsibilities
- Hard to test

**Solution:**

**Step 1:** Extract phases (2h)
```typescript
// index.ts

async function setupServer(): Promise<Server> {
  validateEnvironment();

  const logger = setupLogging();
  const container = setupDependencyInjection(logger);
  const registry = setupToolRegistry(container);
  const server = createMcpServer();

  registerServerHandlers(server, registry, container);

  return server;
}

// Extracted functions
function validateEnvironment(): void { }
function setupLogging(): Logger { }
function setupDependencyInjection(logger: Logger): Container { }
function setupToolRegistry(container: Container): ToolRegistry { }
function createMcpServer(): Server { }
function registerServerHandlers(
  server: Server,
  registry: ToolRegistry,
  container: Container
): void { }
```

**Step 2:** Tests (1h)
- Unit test each phase
- Integration test full setup

**Expected Result:**
- Main function ~20-30 lines
- Each phase ~30-40 lines
- Testable in isolation

---

### 1.5: Schema Optimizations

**Priority:** üü¢ NICE TO HAVE
**Effort:** 1-2 hours
**Impact:** LOW-MEDIUM
**ROI:** ‚≠ê‚≠ê‚≠ê

**Problem:**
- Large schema duplication in create/update pairs
- 41 lines in Project schemas

**Solution:**

**Option 1:** Use Zod .partial()
```typescript
// create-project.schema.ts
export const CreateProjectSchema = z.object({
  name: z.string(),
  // ... all fields
});

// update-project.schema.ts
export const UpdateProjectSchema = CreateProjectSchema.partial();
```

**Option 2:** Base schema + extend
```typescript
// base-project.schema.ts
const BaseProjectSchema = z.object({
  name: z.string(),
  // ... common fields
});

// create-project.schema.ts
export const CreateProjectSchema = BaseProjectSchema.extend({
  // create-specific fields
});

// update-project.schema.ts
export const UpdateProjectSchema = BaseProjectSchema.partial().extend({
  // update-specific fields
});
```

**Affected schemas:**
- Project (41 lines duplicate)
- Checklist (27 lines duplicate)
- Board (19 lines duplicate)

**Expected Result:**
- Reduced duplication by ~50-70 lines
- DRY principle compliance

---

### 1.6: Minor Fixes

**Priority:** üü¢ LOW
**Effort:** 30 minutes
**Impact:** LOW
**ROI:** ‚≠ê‚≠ê

**Fix 1:** Remove unused ESLint directives (3 places)
- infrastructure/src/http/error/api-error.class.ts:99
- infrastructure/src/http/error/error-mapper.ts:57
- yandex-tracker/src/composition-root/container.ts:225

**Fix 2:** Fix no-identical-expressions
- yandex-tracker/src/tools/api/issues/update/update-issue.tool.ts:75

**Fix 3:** Fix nested template literals (2 places)
- board/get-boards.operation.ts:39
- project/get-projects.operation.ts:39

**Effort:** 10-15 minutes each

---

## Phase 1 Summary

**Total Effort:** 8-12 hours
**Can Execute:** Immediately (parallel with 2.1/2.2)

**Expected Improvements:**

| Metric | Before | After Phase 1 | Improvement |
|--------|--------|---------------|-------------|
| Code Duplication | 2.16% | ~1.5% | ‚Üì 30% |
| CLI Connector Lines | ~750 | ~350 | ‚Üì 53% |
| Type Assertions | 102 | ~87 | ‚Üì 15 |
| Max Function Size | 214 | ~40-50 | ‚Üì 77% |
| Complexity (logger) | 18 | ~8 | ‚Üì 56% |
| **Quality Score** | **4.3/5** | **4.5/5** | **+0.2** |

---

## Phase 2: Architecture-Dependent

**Timeline:** 6-10 hours
**Can start:** After 2.1 completion
**Risk:** MEDIUM

---

### 2.1: Refactor tool-registry.ts

**Priority:** üî¥ CRITICAL
**Effort:** 6-8 hours
**Impact:** HIGH
**ROI:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê

**Dependency:** ‚è∏Ô∏è **WAIT for 2.1 Framework Packages Analysis**

**Reason:**
- tool-registry.ts - core component of Framework
- Changes may affect architecture
- Need to coordinate with overall Framework strategy

**Problem:**
- God Object (549 lines)
- High complexity (cognitive 28, cyclomatic 17)
- Multiple responsibilities

**Proposed Solution:**

**Option A:** Split by responsibility
```
packages/framework/core/src/
‚îú‚îÄ‚îÄ tool-registry/
‚îÇ   ‚îú‚îÄ‚îÄ tool-registry.ts           (main class, ~100 lines)
‚îÇ   ‚îú‚îÄ‚îÄ registry-querying.ts       (getDefinitions methods)
‚îÇ   ‚îú‚îÄ‚îÄ registry-filtering.ts      (filtering logic)
‚îÇ   ‚îî‚îÄ‚îÄ tool-executor.ts           (execute method)
```

**Option B:** Extract strategies
```
packages/framework/core/src/
‚îú‚îÄ‚îÄ tool-registry.ts               (main class, ~150 lines)
‚îú‚îÄ‚îÄ strategies/
‚îÇ   ‚îú‚îÄ‚îÄ category-filter.strategy.ts
‚îÇ   ‚îú‚îÄ‚îÄ mode-filter.strategy.ts
‚îÇ   ‚îî‚îÄ‚îÄ definition-grouping.strategy.ts
‚îî‚îÄ‚îÄ execution/
    ‚îî‚îÄ‚îÄ tool-executor.ts
```

**Steps:**

**Step 1:** Wait for 2.1 results (dependency)
- Review Framework architecture recommendations
- Identify best approach for tool-registry split
- Coordinate with overall strategy

**Step 2:** Design refactoring (1-2h)
- Choose approach (A or B, or hybrid)
- Define interfaces
- Plan migration strategy

**Step 3:** Implement split (3-4h)
- Create new modules
- Move code
- Update imports
- Maintain backward compatibility

**Step 4:** Tests and validation (2h)
- Update unit tests
- Integration tests
- Regression tests
- Performance tests

**Expected Result:**
- Main file: ~100-150 lines (vs 549)
- Complexity: ~10-12 (vs 17/28)
- Better testability
- Easier maintenance

---

## Phase 2 Summary

**Total Effort:** 6-10 hours
**Can Execute:** After 2.1 completion

**Expected Improvements:**

| Metric | After Phase 1 | After Phase 2 | Total Improvement |
|--------|---------------|---------------|-------------------|
| Max File Size | 549 | 150 | ‚Üì 73% |
| Max Cognitive Complexity | 28 | ~12 | ‚Üì 57% |
| God Objects | 2 | 0 | ‚Üì 100% |
| **Quality Score** | **4.5/5** | **4.8/5** | **+0.5** |

---

## Execution Timeline

```
Week 1-2: Phase 1 (parallel with 2.1/2.2)
‚îú‚îÄ‚îÄ Day 1-2: BaseConnector creation
‚îú‚îÄ‚îÄ Day 2-3: Type safety improvements
‚îú‚îÄ‚îÄ Day 3-4: Function extraction (logger, setupServer)
‚îú‚îÄ‚îÄ Day 4-5: Schema optimizations + minor fixes
‚îî‚îÄ‚îÄ Day 5: Tests and validation

[WAIT FOR 2.1 COMPLETION]

Week N: Phase 2
‚îú‚îÄ‚îÄ Day 1: Review 2.1 results, plan registry refactoring
‚îú‚îÄ‚îÄ Day 2-3: Implement tool-registry split
‚îú‚îÄ‚îÄ Day 4: Tests and validation
‚îî‚îÄ‚îÄ Day 5: Integration and final checks
```

---

## Testing Strategy

### Phase 1 Testing
- Unit tests for each new component
- Integration tests for refactored code
- Regression tests (ensure no breaking changes)
- Smoke tests after each step

### Phase 2 Testing
- Comprehensive unit tests
- Integration tests
- Performance benchmarks (ensure no degradation)
- Full regression suite

---

## Rollback Plan

**For each change:**
1. Feature branch for development
2. Code review before merge
3. Incremental commits
4. Easy rollback if issues found

**If Phase 1 issues:**
- Rollback individual changes (independent)
- No dependencies between Phase 1 tasks

**If Phase 2 issues:**
- More complex (core component)
- Comprehensive testing before merge
- Staged rollout if needed

---

## Success Criteria

### Phase 1
- [ ] All Phase 1 tasks completed
- [ ] Code duplication < 1.5%
- [ ] No regressions in tests
- [ ] Quality score ‚â• 4.5/5
- [ ] Code review approved

### Phase 2
- [ ] tool-registry.ts refactored
- [ ] Max file size < 200 lines
- [ ] Max cognitive complexity < 15
- [ ] No God Objects
- [ ] Quality score ‚â• 4.8/5
- [ ] Performance maintained/improved

---

## Risks and Mitigation

### Risk 1: Breaking Changes
**Mitigation:**
- Comprehensive tests
- Backward compatibility
- Feature flags if needed

### Risk 2: Performance Degradation
**Mitigation:**
- Benchmarks before/after
- Performance tests
- Optimization if needed

### Risk 3: Coordination with 2.1/2.2
**Mitigation:**
- Clear communication
- Wait for architecture decisions
- Align strategies

---

## Conclusion

**Phase 1:** Ready to execute immediately. Low risk, high ROI.

**Phase 2:** Wait for 2.1 results. Coordinate architecture strategy.

**Expected Outcome:** Quality score 4.8/5, industry-leading code quality.

---

## Next Steps

1. ‚úÖ Execution plan created
2. ‚è≠Ô∏è Start Phase 1 tasks (can begin now)
3. ‚è∏Ô∏è Wait for 2.1 completion
4. ‚è≠Ô∏è Execute Phase 2 after coordination
