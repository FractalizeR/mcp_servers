#!/usr/bin/env tsx

/**
 * –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ tools
 *
 * –ò–∑–≤–ª–µ–∫–∞–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ –∏–∑ –≤—Å–µ—Ö tools –∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç TypeScript —Ñ–∞–π–ª
 * —Å pre-computed –¥–∞–Ω–Ω—ã–º–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
 *
 * –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–¥ build: "prebuild": "tsx scripts/generate-tool-index.ts"
 *
 * Responsibilities:
 * - –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö METADATA –∏–∑ tool –∫–ª–∞—Å—Å–æ–≤
 * - –¢–æ–∫–µ–Ω–∏–∑–∞—Ü–∏—è –∏–º—ë–Ω –∏ –æ–ø–∏—Å–∞–Ω–∏–π
 * - –ì–µ–Ω–µ—Ä–∞—Ü–∏—è TypeScript —Ñ–∞–π–ª–∞ —Å –∏–Ω–¥–µ–∫—Å–æ–º
 * - –í–∞–ª–∏–¥–∞—Ü–∏—è –Ω–∞–ª–∏—á–∏—è METADATA –≤–æ –≤—Å–µ—Ö tools
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

// –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º tool classes (–±–µ–∑ –∏–Ω—Å—Ç–∞–Ω—Ü–∏—Ä–æ–≤–∞–Ω–∏—è)
import { TOOL_CLASSES } from '../src/composition-root/definitions/tool-definitions.js';
import type { StaticToolMetadata, ToolCategory } from '../src/mcp/tools/base/tool-metadata.js';
import type { StaticToolIndex } from '../src/mcp/search/types.js';

/**
 * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è tool –∫–ª–∞—Å—Å–∞ —Å–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–º–∏ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–º–∏
 */
interface ToolWithMetadata {
  METADATA: StaticToolMetadata;
}

/**
 * –¢–æ–∫–µ–Ω–∏–∑–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞
 *
 * - –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ lowercase
 * - –ó–∞–º–µ–Ω–∞ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª–µ–π –Ω–∞ –ø—Ä–æ–±–µ–ª—ã
 * - –†–∞–∑–±–∏–µ–Ω–∏–µ –ø–æ non-word —Å–∏–º–≤–æ–ª–∞–º
 * - –£–¥–∞–ª–µ–Ω–∏–µ –ø—É—Å—Ç—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤
 */
function tokenize(text: string): string[] {
  return text
    .toLowerCase()
    .replace(/[_-]/g, ' ')
    .split(/\W+/)
    .filter((token) => token.length > 0);
}

/**
 * –ü–æ–ª—É—á–∏—Ç—å –∫—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–ø–µ—Ä–≤–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ)
 */
function getShortDescription(description: string): string {
  const firstSentence = description.split(/[.!?]/)[0];
  return firstSentence ? firstSentence.trim() : description;
}

/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞
 */
function generateIndex(): StaticToolIndex[] {
  const index: StaticToolIndex[] = [];

  for (const ToolClass of TOOL_CLASSES) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
    if (!('METADATA' in ToolClass)) {
      throw new Error(
        `‚ùå ${ToolClass.name} must have static METADATA property for index generation.\n` +
          `   Add: static readonly METADATA = { name, description, category, tags, isHelper }`
      );
    }

    const metadata = (ToolClass as unknown as ToolWithMetadata).METADATA;

    // –í–∞–ª–∏–¥–∞—Ü–∏—è –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö
    if (!metadata.name || typeof metadata.name !== 'string') {
      throw new Error(`‚ùå ${ToolClass.name}: METADATA.name is required and must be a string`);
    }

    if (!metadata.description || typeof metadata.description !== 'string') {
      throw new Error(
        `‚ùå ${ToolClass.name}: METADATA.description is required and must be a string`
      );
    }

    if (!metadata.category) {
      throw new Error(`‚ùå ${ToolClass.name}: METADATA.category is required`);
    }

    if (!Array.isArray(metadata.tags)) {
      throw new Error(`‚ùå ${ToolClass.name}: METADATA.tags must be an array`);
    }

    if (typeof metadata.isHelper !== 'boolean') {
      throw new Error(`‚ùå ${ToolClass.name}: METADATA.isHelper must be a boolean`);
    }

    // –°–æ–∑–¥–∞—ë–º –∏–Ω–¥–µ–∫—Å–Ω—É—é –∑–∞–ø–∏—Å—å
    index.push({
      name: metadata.name,
      category: metadata.category,
      tags: metadata.tags,
      isHelper: metadata.isHelper,
      nameTokens: tokenize(metadata.name),
      descriptionTokens: tokenize(metadata.description),
      descriptionShort: getShortDescription(metadata.description),
    });
  }

  return index;
}

/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è TypeScript —Ñ–∞–π–ª–∞ —Å –∏–Ω–¥–µ–∫—Å–æ–º
 */
function generateTypeScriptFile(index: StaticToolIndex[]): string {
  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∏–Ω–¥–µ–∫—Å –≤ TypeScript –∫–æ–¥ —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏
  const indexCode = index
    .map((tool) => {
      const tagsStr = tool.tags.map((t) => `'${t}'`).join(', ');
      const nameTokensStr = tool.nameTokens.map((t) => `'${t}'`).join(', ');
      const descTokensStr = tool.descriptionTokens.map((t) => `'${t}'`).join(', ');

      return `  {
    name: '${tool.name}',
    category: ToolCategory.${String(tool.category).toUpperCase().replace(/-/g, '_')},
    tags: [${tagsStr}],
    isHelper: ${tool.isHelper},
    nameTokens: [${nameTokensStr}],
    descriptionTokens: [${descTokensStr}],
    descriptionShort: '${tool.descriptionShort.replace(/'/g, "\\'")}',
  }`;
    })
    .join(',\n');

  return `/**
 * –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∏–Ω–¥–µ–∫—Å tools –¥–ª—è –ø–æ–∏—Å–∫–∞
 *
 * ü§ñ AUTO-GENERATED - DO NOT EDIT MANUALLY
 * Generated by: scripts/generate-tool-index.ts
 *
 * Regenerate: npm run generate:index
 */

import { ToolCategory } from '@mcp/tools/base/tool-metadata.js';

/**
 * –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∏–Ω–¥–µ–∫—Å tool –¥–ª—è compile-time –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏
 *
 * –°–æ–¥–µ—Ä–∂–∏—Ç pre-computed –¥–∞–Ω–Ω—ã–µ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
 */
export interface StaticToolIndex {
  /** –ò–º—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ */
  name: string;

  /** –ö–∞—Ç–µ–≥–æ—Ä–∏—è */
  category: ToolCategory;

  /** –¢–µ–≥–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞ */
  tags: string[];

  /** Helper –∏–ª–∏ API tool */
  isHelper: boolean;

  /** Pre-computed —Ç–æ–∫–µ–Ω—ã –∏–∑ –∏–º–µ–Ω–∏ */
  nameTokens: string[];

  /** Pre-computed —Ç–æ–∫–µ–Ω—ã –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è */
  descriptionTokens: string[];

  /** –ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ (–±–µ–∑ inputSchema) */
  descriptionShort: string;
}

/**
 * –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –∏–Ω–¥–µ–∫—Å –≤—Å–µ—Ö tools
 *
 * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è ToolSearchEngine –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
 */
export const TOOL_SEARCH_INDEX: readonly StaticToolIndex[] = [
${indexCode}
] as const;
`;
}

/**
 * –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
 */
async function main(): Promise<void> {
  console.log('üîç –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ tools...\n');

  try {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏–Ω–¥–µ–∫—Å
    const index = generateIndex();

    console.log(`‚úÖ –ü—Ä–æ–∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–æ tools: ${index.length}`);
    console.log();

    // –í—ã–≤–æ–¥–∏–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
    const categories = new Map<string, number>();
    const helperCount = index.filter((t) => t.isHelper).length;

    for (const tool of index) {
      const count = categories.get(tool.category) || 0;
      categories.set(tool.category, count + 1);
    }

    console.log('üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:');
    console.log(`   API tools: ${index.length - helperCount}`);
    console.log(`   Helper tools: ${helperCount}`);
    console.log();
    console.log('   –ü–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º:');
    for (const [category, count] of Array.from(categories.entries()).sort()) {
      console.log(`     - ${category}: ${count}`);
    }
    console.log();

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º TypeScript —Ñ–∞–π–ª
    const output = generateTypeScriptFile(index);

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ –≤—ã—Ö–æ–¥–Ω–æ–º—É —Ñ–∞–π–ª—É
    const outputPath = path.join(
      path.dirname(fileURLToPath(import.meta.url)),
      '../src/mcp/search/generated-index.ts'
    );

    // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º —Ñ–∞–π–ª
    fs.writeFileSync(outputPath, output, 'utf-8');

    // –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Ñ–∞–π–ª —á–µ—Ä–µ–∑ Prettier –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
    try {
      execSync(`npx prettier --write "${outputPath}"`, { stdio: 'pipe' });
    } catch (error) {
      console.warn('‚ö†Ô∏è  –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª —á–µ—Ä–µ–∑ Prettier');
    }

    console.log(`‚úÖ –ò–Ω–¥–µ–∫—Å —Å–æ—Ö—Ä–∞–Ω—ë–Ω: ${path.relative(process.cwd(), outputPath)}`);
    console.log('   –†–∞–∑–º–µ—Ä:', Buffer.byteLength(output, 'utf8'), 'bytes');
    console.log();
    console.log('‚ú® –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!');
  } catch (error) {
    console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–Ω–¥–µ–∫—Å–∞:\n');

    if (error instanceof Error) {
      console.error(error.message);
      if (error.stack) {
        console.error('\nStack trace:');
        console.error(error.stack);
      }
    } else {
      console.error(error);
    }

    process.exit(1);
  }
}

// –ó–∞–ø—É—Å–∫
main().catch((error) => {
  console.error('‚ùå –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞:', error);
  process.exit(1);
});
